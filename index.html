<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="光阴给我们经验,读书给我们知识.">
<meta property="og:type" content="website">
<meta property="og:title" content="ShiJian">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ShiJian">
<meta property="og:description" content="光阴给我们经验,读书给我们知识.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ShiJian">
<meta name="twitter:description" content="光阴给我们经验,读书给我们知识.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>ShiJian</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShiJian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/04/UIView详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/04/UIView详解/" itemprop="url">UIView详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-04T22:00:55+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/04/UIView详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/04/UIView详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>视图是应用程序中用户界面的基本组成部分，<code>UIView</code>类定义了所有视图的通用行为。视图在其边界矩形内呈现内容，并处理与该内容有关的任何交互。<code>UIView</code>类是一个具体类，可以使用其实例对象来显示一个固定的背景颜色，也可以子类化<code>UIView</code>来绘制更复杂的内容。要展示应用程序中常见的标签、图像、 按钮 和其它界面元素，应首先选择使用UIKit框架提供的视图子类。</p>
<p>视图对象是应用程序与用户交互的主要方式，其主要职责有：</p>
<ul>
<li>绘制图形和执行动画</li>
<li>使用UIKit框架或者Core Graphics框架在视图的矩形区域中绘制内容。</li>
<li>视图的一些属性值可以用来执行动画。</li>
<li>布局和管理子视图</li>
<li>视图可能包含多个子视图。</li>
<li>视图可以调整子视图的大小和位置。</li>
<li>使用Auto Layout定义调整视图大小和重新定位视图的规则，并以此规则来响应视图层的更改。</li>
<li>事件处理</li>
<li>视图对象是<code>UIResponder</code>类的子类对象，能够响应触摸事件和其它类型的事件。</li>
<li>视图可以附加手势识别器来处理常见的手势。</li>
</ul>
<h2 id="创建和管理视图层次结构"><a href="#创建和管理视图层次结构" class="headerlink" title="创建和管理视图层次结构"></a>创建和管理视图层次结构</h2><p>管理视图层次结构是开发应用程序用户界面的关键部分，视图层次结构会影响应用程序用户界面的外观以及应用程序如何响应更改和事件。下图显示了时钟应用程序的视图层次结构，标签栏和导航视图是标签栏和导航视图控制器对象提供的特殊视图层次结构，用于管理整个用户界面的各个部分。</p>
<p><img src="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/windowlayers.jpg" alt="图2-1"></p>
<h3 id="添加和移除视图"><a href="#添加和移除视图" class="headerlink" title="添加和移除视图"></a>添加和移除视图</h3><p>Interface Builder是创建视图层次结构最便捷的方式，因为我们可以使用图形方式来组装视图，查看视图之间的关系，并确切了解在运行时将如何显示这些视图。如果以编程方式创建视图，可以使用以下方法来排列视图层次结构：</p>
<ul>
<li>要将子视图添加到父视图，请调用父视图的<code>addSubview:</code>方法，此方法将子视图添加到父级子视图层的最上层。</li>
<li>要在父视图和子视图中间插入子视图，请调用父视图的任一<code>insertSubview:...</code>方法，此方法会将子视图插入到父视图和给定子视图之间的视图层的最上层。</li>
<li>要对父视图中的现有子视图进行重新排列，请调用父视图的<code>bringSubviewToFront:</code>、<code>sendSubviewToBack:</code>或者<code>exchangeSubviewAtIndex:withSubviewAtIndex:</code>方法，使用这些方法比删除子视图并重新插入它们效率要快。</li>
<li>要从父视图移除子视图，请调用<strong>子视图</strong>的<code>removeFromSuperview</code>方法。</li>
</ul>
<p>子视图的<code>frame</code>属性值决定了视图在其父视图坐标系中的原点和尺寸，<code>bounds</code>属性值决定了视图的内部尺寸。默认情况下，当子视图的可见区域超出其父视图的矩形区域时，不会对子视图内容作裁剪，但可以设置父视图对象的<code>clipsToBounds</code>属性值来更改默认行为。</p>
<p>可以在视图控制器的<code>loadView</code>或者<code>viewDidLoad</code>方法中添加子视图到当前视图层。如果是以编程方式创建视图，则在视图控制器的<code>loadView</code>方法中创建添加视图。无论是以编程方式创建视图还是从<strong>nib文件</strong>中加载视图，都可以放在视图控制器的<code>viewDidLoad</code>方法中执行。</p>
<p>将子视图添加到另一个视图时，UIKit会通知父视图和子视图。在实现自定义视图时，可以通过覆写<code>willMoveToSuperview:</code>、<code>willMoveToWindow:</code>、<code>willRemoveSubview:</code>、<code>didAddSubview:</code>、<code>didMoveToSuperview</code>或者<code>didMoveToWindow</code>方法中一个或者多个来拦截这些通知。可以使用这些通知来更新与视图层次结构相关的任何状态信息或者执行其它任务。</p>
<h3 id="隐藏视图"><a href="#隐藏视图" class="headerlink" title="隐藏视图"></a>隐藏视图</h3><p>要以可视化方式隐藏视图，可以将视图的<code>hidden</code>属性值设为<code>YES</code>或者将其<code>alpha</code>属性值设为<code>0.0</code>。被隐藏的视图不会从系统接收到触摸事件，但是可以参与与视图层次结构相关的自动调整和其它布局操作。如果想要动画隐藏或呈现视图，必须使用视图的<code>alpha</code>属性，<code>hidden</code>属性不支持动画。</p>
<h3 id="在视图层中定位视图"><a href="#在视图层中定位视图" class="headerlink" title="在视图层中定位视图"></a>在视图层中定位视图</h3><p>在视图层中定位视图有2种方法：</p>
<ul>
<li>在适当位置存储视图对象的指针，例如在拥有此视图的视图控制器中。</li>
<li>为每个视图的<code>tag</code>属性分配一个<strong>唯一的整数</strong>，并调用其父视图或者其父视图的更下层父视图的<code>viewWithTag:</code>方法来定位它。</li>
</ul>
<p><code>viewWithTag:</code>方法会从调用该方法的视图的视图分支遍历视图获取对应<code>tag</code>值的视图，在使用该方法定位视图时，调用其父视图的<code>viewWithTag:</code>方法比调用其父视图的更下层父视图的<code>viewWithTag:</code>方法的效率要快。</p>
<h3 id="平移、-缩放和旋转视图"><a href="#平移、-缩放和旋转视图" class="headerlink" title="平移、 缩放和旋转视图"></a>平移、 缩放和旋转视图</h3><p>每个视图对象都关联有一个<code>transform</code>仿射变换属性，可以通过配置<code>transform</code>属性值来平移、 缩放和旋转视图的内容。<code>UIView</code>的<code>transform</code>属性包含一个<code>CGAffineTransform</code>结构体，默认情况下，不会修改视图的外观。我们可以随时分配一个新的转换，例如将视图旋转45度，可以使用以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGAffineTransform xform = CGAffineTransformMakeRotation(M_PI/4.0);</div><div class="line"></div><div class="line">self.view.transform = xform;</div></pre></td></tr></table></figure></p>
<p>将多个转换同时应用于视图时，将这些转换添加到<code>CGAffineTransform</code>结构体的顺序非常重要。先旋转视图然后平移视图与先平移视图然后旋转视图的最终效果是不一样的，即使在每种情况下旋转和平移的数值都是一样的。此外，任何转换都是相对于视图的中心点而变换的。缩放和旋转视图时，不会改变视图的中心点。有关创建和使用仿射变换的更多信息，可以参看<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066" target="_blank" rel="external">Quartz 2D Programming Guide</a>中的<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_affine/dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204" target="_blank" rel="external">Transforms</a>.</p>
<h3 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h3><p>在某些情况下，特别是在处理触摸事件时，应用程序可能需要将视图的坐标参考系从一个视图转移到另一个视图。例如触摸事件会报告每次触摸在<code>window</code>坐标系中位置，但通常我们只需要视图在其所在视图层分支中的视图坐标系中的位置。<code>UIView</code>类定义了以下转换视图坐标参考系的方法：</p>
<ul>
<li><code>convertPoint:fromView:</code></li>
<li><code>convertRect:fromView:</code></li>
<li><code>convertPoint:toView:</code></li>
<li><code>convertRect:toView:</code></li>
</ul>
<p><code>convert...:fromView:</code>方法将坐标点的坐标参考系从给定视图的坐标系转换为调用此方法的视图的局部坐标系，而<code>convert...:toView:</code>则将坐标点的坐标参考系从调用此方法的视图的局部坐标系转换为给定视图的坐标系。如果这两类方法的给定参考视图为<code>nil</code>，则会自动指定参考视图为当前视图所在的<code>window</code>。</p>
<p><code>UIWindow</code>也定义了几种转换坐标参考系的方法：</p>
<ul>
<li><code>convertPoint:fromWindow:</code></li>
<li><code>convertRect:fromWindow:</code></li>
<li><code>convertPoint:toWindow:</code></li>
<li><code>convertRect:toWindow:</code></li>
</ul>
<p>在被旋转过的视图中转换坐标时，UIKit会假定一个大小刚好包含此被旋转过视图的屏幕区域为坐标点的坐标参考系，如下图所示：</p>
<p><img src="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/uiview_convert_rotated.jpg" alt="图2-2"></p>
<h2 id="在运行时调整视图的大小和位置"><a href="#在运行时调整视图的大小和位置" class="headerlink" title="在运行时调整视图的大小和位置"></a>在运行时调整视图的大小和位置</h2><p>每当视图的大小发生变化时，其子视图的大小和位置都必须相应地改变。<code>UIView</code>类支持视图层中的视图自动和手动布局。通过自动布局，我们可以设置每个视图在其父视图调整大小时应遵循的布局规则，使其可以自动调整大小和位置。通过手动布局，我们可以根据需要手动调整视图的大小和位置。</p>
<h3 id="布局更改"><a href="#布局更改" class="headerlink" title="布局更改"></a>布局更改</h3><p>视图发生以下任何更改时，可能会使视图的布局发生更改：</p>
<ul>
<li>视图边界矩形的大小发生变化。</li>
<li>屏幕方向的变换，通常会使根视图的边界矩形发生更改。</li>
<li>与视图的图层相关联的核心动画子图层组发生更改，并且需要布局。</li>
<li>调用视图的<code>setNeedsLayout</code>或者<code>layoutIfNeeded</code>方法来强制执行布局。</li>
<li>调用视图图层的<code>setNeedsLayout</code>方法来强制布局。</li>
</ul>
<h3 id="自动调整视图布局"><a href="#自动调整视图布局" class="headerlink" title="自动调整视图布局"></a>自动调整视图布局</h3><p>当视图的大小发生更改时，通常需要更改其子视图的位置和大小以适配其父视图的大小。父视图的<code>autoresizesSubviews</code>属性决定子视图是否调整大小，如果此属性值为<code>YES</code>，则该父视图会根据其子视图的<code>autoresizingMask</code>属性来确定如何调整和定位该子视图。对任何子视图的大小进行更改也会触发子视图的子视图的布局调整。</p>
<p>对于视图层中的每个视图，要使其支持自动布局，就必须将其<code>autoresizingMask</code>属性设置为合适的值。下表列出了可应用于视图的自动调整布局选项，并描述了其在布局操作期间所起的效果。为<code>autoresizingMask</code>属性分配值时，可以使用<strong>OR运算符组合这些常量</strong>，或者将这些常量相加后再赋值。</p>
<table>
<thead>
<tr>
<th>Autoresizing mask</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UIViewAutoresizingNone</td>
<td>视图不会自动调整大小(默认值)</td>
</tr>
<tr>
<td>UIViewAutoresizingFlexibleHeight</td>
<td>根据需要调整视图的高度，以保证上边距和下边距不变。</td>
</tr>
<tr>
<td>UIViewAutoresizingFlexibleWidth</td>
<td>根据需要调整视图的宽度，以保证左边距和右边距不变。</td>
</tr>
<tr>
<td>UIViewAutoresizingFlexibleLeftMargin</td>
<td>视图左边距根据需要增大或减小，以保证视图右边距不变。</td>
</tr>
<tr>
<td>UIViewAutoresizingFlexibleRightMargin</td>
<td>视图右边距根据需要增大或减小，以保证视图左边距不变。</td>
</tr>
<tr>
<td>UIViewAutoresizingFlexibleBottomMargin</td>
<td>视图下边距根据需要增大或减小，以保证视图上边距不变。</td>
</tr>
<tr>
<td>UIViewAutoresizingFlexibleTopMargin</td>
<td>视图上边距根据需要增大或减小，以保证视图下边距不变。</td>
</tr>
</tbody>
</table>
<p><img src="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/uiview_autoresize.jpg" alt="图3-1"></p>
<h3 id="手动调整视图布局"><a href="#手动调整视图布局" class="headerlink" title="手动调整视图布局"></a>手动调整视图布局</h3><p>当视图的大小更改时，UIKit就会应用其子视图的自动调整行为，之后会调用视图的<code>layoutSubviews</code>方法。当自定义视图的子视图的自动调整行为不能满足我们的需要时，可以实现该自定义视图的<code>layoutSubviews</code>方法并在其中执行以下任何操作：</p>
<ul>
<li>调整任何子视图的大小和位置。</li>
<li>添加或删除子视图或者核心动画图层。</li>
<li>通过调用子视图的<code>setNeedsDisplay</code>或者<code>setNeedsDisplayInRect:</code>方法强制其执行重绘。</li>
<li>在实现一个大的可滚动区域时，经常需要手动布局子视图。由于直接用一个足够大的视图来呈现可滚动内容是不切实际的，所以应用程序通常会实现一个根视图，其中包含许多较小的视图块。每个小视图块代表可滚动内容的一部分。当滚动事件发生时，根视图调用其<code>setNeedsLayout</code>方法来执行重绘，之后调用<code>layoutSubviews</code>方法并在该方法中根据发生的滚动量重新定位平铺小视图块。</li>
</ul>
<h2 id="与核心动画图层进行交互"><a href="#与核心动画图层进行交互" class="headerlink" title="与核心动画图层进行交互"></a>与核心动画图层进行交互</h2><p>每个视图对象都拥有一个用于管理屏幕上视图内容的显示和动画的核心动画图层。虽然我们可以使用视图对象做很多事情，但也可以根据需要直接使用其图层对象。视图的图层对象存储在视图的<code>layer</code>属性中。</p>
<h3 id="更改与视图关联的图层对象的所属类型"><a href="#更改与视图关联的图层对象的所属类型" class="headerlink" title="更改与视图关联的图层对象的所属类型"></a>更改与视图关联的图层对象的所属类型</h3><p>与视图关联的图层对象所属类型在创建视图之后就无法被更改了，所以视图使用<code>layerClass</code>类方法来指定其图层对象的所属类。此方法的默认实现返回<code>CALayer</code>类，更改此方法返回值的唯一方法就是子类化<code>UIView</code>并重写该方法返回一个不同的类。例如，如果使用平铺来显示大的可滚动区域，则可能需要使用<code>CATiledLayer</code>类来支持视图，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (Class)layerClass</div><div class="line">&#123;</div><div class="line">return [CATiledLayer class];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>视图会在其初始化前先调用其<code>layerClass</code>类方法，并使用返回的类来创建其图层对象。另外，视图总是将自己指定为其图层对象的委托对象。视图持有图层，视图和图层之间的关系不能改变，也不能在指定该视图为另一个图层对象的委托对象。否则，会导致绘制图形时出问题，应用程序有可能崩溃。</p>
<p>有关<strong>Core Animation</strong>提供的不同类型的图层对象的更多信息，可以参看<a href="https://developer.apple.com/documentation/quartzcore" target="_blank" rel="external">Core Animation Reference Collection</a>。</p>
<h3 id="在视图中嵌入图层对象"><a href="#在视图中嵌入图层对象" class="headerlink" title="在视图中嵌入图层对象"></a>在视图中嵌入图层对象</h3><p>如果要使用图层对象而不用视图，则可以根据需要将自定义图层对象添加到图层中。自定义图层对象是属于<code>CALayer</code>类的任何实例，通常以编程方式来创建自定义图层，并使用Core Animation的规则将其合并。自定义图层不会接收到事件，也不会参与响应者链，但能根据Core Animation的规则绘制自己的图形并响应其父视图或父图层中的大小更改。</p>
<p>使用自定义图层对象显示静态图片的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line"></div><div class="line">// Create the layer.</div><div class="line">CALayer* myLayer = [[CALayer alloc] init];</div><div class="line"></div><div class="line">// Set the contents of the layer to a fixed image. And set</div><div class="line">// the size of the layer to match the image size.</div><div class="line">UIImage layerContents = [[UIImage imageNamed:@&quot;myImage&quot;] retain];</div><div class="line">CGSize imageSize = layerContents.size;</div><div class="line"></div><div class="line">myLayer.bounds = CGRectMake(0, 0, imageSize.width, imageSize.height);</div><div class="line">myLayer = layerContents.CGImage;</div><div class="line"></div><div class="line">// Add the layer to the view.</div><div class="line">CALayer*    viewLayer = self.view.layer;</div><div class="line">[viewLayer addSublayer:myLayer];</div><div class="line"></div><div class="line">// Center the layer in the view.</div><div class="line">CGRect        viewBounds = backingView.bounds;</div><div class="line">myLayer.position = CGPointMake(CGRectGetMidX(viewBounds), CGRectGetMidY(viewBounds));</div><div class="line"></div><div class="line">// Release the layer, since it is retained by the view&apos;s layer</div><div class="line">[myLayer release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以添加任意数量的子图层到视图的图层，有关如何直接使用图层的信息，可以参看<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514" target="_blank" rel="external">Core Animation Programming Guide</a>。</p>
<h2 id="视图绘图周期"><a href="#视图绘图周期" class="headerlink" title="视图绘图周期"></a>视图绘图周期</h2><p>当首次显示视图时，或者由于布局更改而全部或部分视图变为可见时，系统会调用视图的<code>drawRect:</code>方法来绘制其内容。可以在此方法中将视图的内容绘制到当前图形上下文中，该图形上下文在调用此方法之前由系统自动设置。<strong>注意，系统每次设置当前图形上下文可能并不相同，所以在每次绘制时，需要使用<code>UIGraphicsGetCurrentContext</code>方法来重新获取当前图形上下文。</strong></p>
<p>当视图的实际内容发生变化时，需要调用视图的<code>setNeedsDisplay</code>或者<code>setNeedsDisplayInRect:</code>方法来通知系统当前视图需要重新绘制。这些方法会标记当前视图需要更新，系统会在下一个绘图周期中更新视图。由于在调用这些方法后，系统会等到下一个绘图周期才更新视图，所以可以在多个视图中调用这些方法来同时更新它们。</p>
<p><strong>注意：如果使用OpenGL ES来执行绘图，则应使用<code>GLKView</code>类，有关如何使用OpenGL ES进行绘制的更多信息，可以参看<a href="https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793" target="_blank" rel="external">OpenGL ES Programming Guide</a>。</strong></p>
<h2 id="动画更改视图的属性"><a href="#动画更改视图的属性" class="headerlink" title="动画更改视图的属性"></a>动画更改视图的属性</h2><p>视图的<code>frame</code>、<code>bounds</code>、<code>center</code>、<code>transform</code>、<code>alpha</code>和<code>backgroundColor</code>属性是可以用来执行动画。</p>
<h3 id="使用基于Block的方法执行动画"><a href="#使用基于Block的方法执行动画" class="headerlink" title="使用基于Block的方法执行动画"></a>使用基于Block的方法执行动画</h3><p>iOS 4 以后，可以使用使用基于Block的方法来执行动画。有以下几种基于Block的方法为动画块提供不同级别的配置：</p>
<ul>
<li><code>animateWithDuration:animations:</code></li>
<li><code>animateWithDuration:animations:completion:</code></li>
<li><code>animateWithDuration:delay:options:animations:completion</code></li>
</ul>
<p>这些方法都是类方法，使用它们创建的动画块不会绑定到单个视图。因此，可以使用这些方法创建一个包含对多个视图进行更改的动画。例如，在某个时间段淡入淡出执行视图显示和隐藏动画。其代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:1.0 animations:^&#123;</div><div class="line"></div><div class="line">firstView.alpha = 0.0;</div><div class="line">secondView.alpha = 1.0;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>程序执行以上代码时，会在另一个线程执行指定的动画，以避免阻塞当前线程或应用程序的主线程。</p>
<p>如果要更改默认的动画参数，则必须使用<code>animateWithDuration:delay:options:animations:completion</code>方法来执行动画。可以通过该方法来自定义以下动画参数：</p>
<ul>
<li>延迟开始执行的动画的时间</li>
<li>动画时使用的时间曲线的类型</li>
<li>动画重复执行的次数</li>
<li>当动画执行到最后时，动画是否自动反转</li>
<li>在动画执行过程中，视图是否能接收触摸事件</li>
<li>动画是否应该中断任何正在执行的动画，或者等到正在执行的动画完成之后才开始</li>
</ul>
<p>另外，<code>animateWithDuration:animations:completion:</code>和<code>animateWithDuration:delay:options:animations:completion</code>方法可以指定动画完成后的执行代码块，可以在块中将单独的动画链接起来。例如，第一次调用<code>animateWithDuration:delay:options:animations:completion</code>方法设置一个淡出动画，并配置一些动画参数。当动画完成后，在动画完成后的执行代码块中延迟执行淡入动画。其代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// Fade out the view right away</div><div class="line">[UIView animateWithDuration:1.0</div><div class="line">delay:0.0</div><div class="line">options:UIViewAnimationOptionCurveEaseIn</div><div class="line">animations:^&#123;</div><div class="line"></div><div class="line">thirdView.alpha = 0.0;</div><div class="line"></div><div class="line">&#125;completion:^(BOOL finished)&#123;</div><div class="line"></div><div class="line">// Wait one second and then fade in the view</div><div class="line">[UIView animateWithDuration:1.0</div><div class="line">delay:1.0</div><div class="line">options:UIViewAnimationOptionCurveEaseOut</div><div class="line">animations:^&#123;</div><div class="line"></div><div class="line">thirdView.alpha = 1.0;</div><div class="line"></div><div class="line">&#125;completion:nil];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>重要：当正在对视图的某个属性执行动画时，此时更改该属性值不会停止当前动画。相反，当前动画会继续执行，并动画到刚分配给该属性的新值。</strong></p>
</blockquote>
<h3 id="使用Begin-Commit方法执行动画"><a href="#使用Begin-Commit方法执行动画" class="headerlink" title="使用Begin/Commit方法执行动画"></a>使用Begin/Commit方法执行动画</h3><p>iOS 4 之前，只能使用<code>UIView</code>类的<code>beginAnimations:context:</code>和<code>commitAnimations</code>类方法来定义动画块，这两个方法用来标记动画块的开始和结束。在调用<code>commitAnimations</code>方法之后，在这两个方法之间更改的任何动画属性都会动画过渡到其新值。动画会在辅助线程上执行，以避免阻塞当前线程或应用程序的主线程。</p>
<p>使用Begin/Commit方法在某个时间段淡入淡出执行视图显示和隐藏动画。其代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[UIView beginAnimations:@&quot;ToggleViews&quot; context:nil];</div><div class="line">[UIView setAnimationDuration:1.0];</div><div class="line"></div><div class="line">// Make the animatable changes.</div><div class="line">firstView.alpha = 0.0;</div><div class="line">secondView.alpha = 1.0;</div><div class="line"></div><div class="line">// Commit the changes and perform the animation.</div><div class="line">[UIView commitAnimations];</div></pre></td></tr></table></figure></p>
<p>默认情况下，在动画块中的所有动画属性更改都是动画过渡的。如果想让某些属性更改不支持动画过渡，可以先调用<code>setAnimationsEnabled:</code>来临时禁用动画，然后执行不需要动画过渡的更改。之后，再次调用<code>setAnimationsEnabled:</code>方法重新启用动画。可以通过调用<code>areAnimationsEnabled</code>类方法来判断动画是否被启用。</p>
<blockquote>
<p><strong>注意：当正在对视图的某个属性执行动画时，此时更改该属性值不会停止当前动画。相反，当前动画会继续执行，并动画到刚分配给该属性的新值。</strong></p>
</blockquote>
<p>可以使用以下类方法为Begin/Commit动画块配置动画参数：</p>
<ul>
<li><code>setAnimationStartDate:</code>：设置开始执行动画的时间。如果设置的日期是过去时间，则会立即执行动画。</li>
<li><code>setAnimationDelay:</code>：设置当前时间延迟多少秒后开始执行动画。</li>
<li><code>setAnimationDuration:</code>：设置动画时长。</li>
<li><code>setAnimationCurve:</code>：设置动画时使用的时间曲线的类型。</li>
<li><code>setAnimationRepeatCount:</code>：设置动画重复次数。</li>
<li><code>setAnimationRepeatAutoreverses:</code>：设置动画完成后是否自动反转。</li>
</ul>
<p>如果想要在动画开始前或完成后执行某些操作，则必须将委托对象和操作方法与动画块关联起来。使用<code>UIView</code>类的<code>setAnimationDelegate:</code>类方法设置委托对象，并使用<code>setAnimationWillStartSelector:</code>和<code>setAnimationDidStopSelector:</code>类方法来设置动画开始前和完成后要执行的方法。系统会在适当的时候调用委托方法，让我们有机会执行需要执行的代码。</p>
<p>动画委托方法的方法名类似于一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)animationWillStart:(NSString *)animationID context:(void *)context;</div><div class="line"></div><div class="line">- (void)animationDidStop:(NSString *)animationID finished:(NSNumber *)finished context:(void *)context;</div></pre></td></tr></table></figure></p>
<p>这两个方法的<code>animationID</code>和<code>context</code>参数与调用<code>beginAnimations:context:</code>方法开启动画时传入的参数相同：</p>
<ul>
<li><code>animationID</code>——用于识别动画的字符串。</li>
<li><code>context</code>——使用该上下文对象传递信息给委托对象。</li>
</ul>
<p>调用<code>setAnimationDidStopSelector:</code>类方法关联的动画停止时执行的方法有一个额外的<code>finished</code>参数，其是一个布尔值。如果动画运行完成，为<code>YES</code>。如果动画被其他动画提前取消或停止，则为<code>NO</code>。</p>
<h3 id="嵌套动画块"><a href="#嵌套动画块" class="headerlink" title="嵌套动画块"></a>嵌套动画块</h3><p>可以通过在动画块内嵌套其他动画块来为动画块的某些部分分配不同的时序和配置选项。嵌套动画会与任何父动画同时启动，但根据它们各自的配置参数来执行。默认情况下，嵌套动画会继承父级动画的持续时间和动画曲线，但可以根据需要重置嵌套动画的这些选项。</p>
<p>以下代码展示了一个如何使用嵌套动画块来改变动画组中的某些动画的开启时间，持续时间和行为的例子。有两个视图正在被淡化为完全透明，但其中一个视图的透明度会在动画结束前来回多次改变。在嵌套动画块中配置的<code>UIViewAnimationOptionOverrideInheritedCurve</code>和<code>UIViewAnimationOptionOverrideInheritedDuration</code>参数将允许嵌套动画使用自己的动画曲线和持续时间值。如果没有配置这些参数，嵌套动画将使用父级动画块的动画曲线和持续时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:1.0</div><div class="line">delay:1.0</div><div class="line">options:UIViewAnimationOptionCurveEaseOut</div><div class="line">animations:^&#123;</div><div class="line"></div><div class="line">aView.alpha = 0.0;</div><div class="line"></div><div class="line">// Create a nested animation that has a different</div><div class="line">// duration, timing curve, and configuration.</div><div class="line">[UIView animateWithDuration:0.2</div><div class="line">delay:0.0</div><div class="line">options:UIViewAnimationOptionOverrideInheritedCurve |</div><div class="line">UIViewAnimationOptionCurveLinear |</div><div class="line">UIViewAnimationOptionOverrideInheritedDuration |</div><div class="line">UIViewAnimationOptionRepeat |</div><div class="line">UIViewAnimationOptionAutoreverse</div><div class="line">animations:^&#123;</div><div class="line"></div><div class="line">[UIView setAnimationRepeatCount:2.5];</div><div class="line"></div><div class="line">anotherView.alpha = 0.0;</div><div class="line">&#125;</div><div class="line">completion:nil];</div><div class="line">&#125;</div><div class="line">completion:nil];</div></pre></td></tr></table></figure>
<p>如果是使用Begin/Commit方法创建动画，其嵌套使用与基于Block的方法类似。在已经创建的动画块中调用<code>beginAnimations:context:</code>方法继续创建一个新的动画块，并根据需要进行配置。任何配置更改都适用于最新创建的动画块。在提交和执行动画前，所有嵌套动画块都必须调用<code>commitAnimations</code>方法提交动画。</p>
<h3 id="反转动画"><a href="#反转动画" class="headerlink" title="反转动画"></a>反转动画</h3><p>创建可重复执行的可反转动画时，要注意将重复次数指定为非整数值。对于可反转动画，每个动画周期内都包含从原始值到新值，然后再还原为原始值的动画。如果希望动画在新值上结束，则重复执行次数要加0.5以增加半个额外动画周期。</p>
<h2 id="视图过渡转换动画"><a href="#视图过渡转换动画" class="headerlink" title="视图过渡转换动画"></a>视图过渡转换动画</h2><p>视图过渡转换可以隐藏在视图层中添加、删除或显示视图带来的视觉上的突然变化。可以使用视图过渡转换来实现以下类型的更改：</p>
<ul>
<li>更改现有视图的可见子视图，使父视图在不同状态之间切换。</li>
<li>当想使界面有很大的改变时，使用不同的视图替换视图层中的某个视图。</li>
</ul>
<blockquote>
<p><strong>注意：不要将视图转换与视图控制器的跳转相混淆，视图转换仅影响视图层。</strong></p>
</blockquote>
<h3 id="更改视图的子视图"><a href="#更改视图的子视图" class="headerlink" title="更改视图的子视图"></a>更改视图的子视图</h3><p>在iOS 4之后，使用<code>transitionWithView:duration:options:animations:completion:</code>方法为视图启动过渡动画。通常情况下，在此方法指定的动画块中，应执行与显示、隐藏、添加或者删除子视图相关的动画。这样就能允许视图对象创建视图在更改之前和更改之后的截图，并且会在这两张截图之间创建动画。这种方式更加高效，但是，如果还需要对其他更改执行动画，则可以在调用此方法时配置<code>UIViewAnimationOptionAllowAnimatedContent</code>选项，这样就可以防止视图对象创建截图，并直接对所有更改执行动画。</p>
<p>以下代码是如何使用过渡转换动画使用户界面看起来好像添加了新的文本输入页面的示例。用户界面包含两个嵌入的文本视图，文本视图的配置相同，但其中一个始终可见，另一个隐藏。当用户点击按钮创建一个新页面时，这个方法切换了两个视图的可见性，导致一个空的文本视图的新空白页面准备接收文本。转换完成后，视图使用私有方法保存旧页面中的文本，并重置现在隐藏的文本视图，以便稍后重新使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (IBAction)displayNewPage:(id)sender</div><div class="line">&#123;</div><div class="line">[UIView transitionWithView:self.view</div><div class="line">duration:1.0</div><div class="line">options:UIViewAnimationOptionTransitionCurlUp</div><div class="line">animations:^&#123;</div><div class="line"></div><div class="line">currentTextView.hidden = YES;</div><div class="line">swapTextView.hidden = NO;</div><div class="line"></div><div class="line">&#125;completion:^(BOOL finished)&#123;</div><div class="line"></div><div class="line">// Save the old text and then swap the views.</div><div class="line">[self saveNotes:temp];</div><div class="line"></div><div class="line">UIView*    temp = currentTextView;</div><div class="line">currentTextView = swapTextView;</div><div class="line">swapTextView = temp;</div><div class="line">&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>iOS 4之前的版本可以使用<code>setAnimationTransition:forView:cache:</code>方法执行视图转换动画，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[UIView beginAnimations:@&quot;ToggleSiblings&quot; context:nil];</div><div class="line">[UIView setAnimationTransition:UIViewAnimationTransitionCurlUp forView:self.view cache:YES];</div><div class="line">[UIView setAnimationDuration:1.0];</div><div class="line"></div><div class="line">// Make your changes</div><div class="line"></div><div class="line"></div><div class="line">[UIView commitAnimations];</div></pre></td></tr></table></figure></p>
<p>另外，还需要设置好委托对象和动画停止后执行的回调方法。</p>
<h3 id="用不同的视图替换视图层中的某个视图"><a href="#用不同的视图替换视图层中的某个视图" class="headerlink" title="用不同的视图替换视图层中的某个视图"></a>用不同的视图替换视图层中的某个视图</h3><p>iOS 4之后，使用<code>transitionFromView:toView:duration:options:completion:</code>方法在两个视图间过渡转换。此方法实际上是从当前视图层中删除第一个视图，然后插入另一个视图。如果要隐藏视图而不是从视图层中删除视图，可以在调用此方法时配置<code>UIViewAnimationOptionShowHideTransitionViews</code>选项。</p>
<p>以下代码展示了如何在单个视图控制器管理的两个主视图之间交换显示。视图控制器的根视图总是显示两个子视图中的一个，每个视图呈现的内容相同，但界面布局不同。视图控制器使用<code>displayingPrimary</code>成员变量(布尔值)来跟踪在任何给定时间显示哪个视图。翻转方向根据正在显示的视图而改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (IBAction)toggleMainViews:(id)sender &#123;</div><div class="line"></div><div class="line">[UIView transitionFromView:(displayingPrimary ? primaryView : secondaryView)</div><div class="line">toView:(displayingPrimary ? secondaryView : primaryView)</div><div class="line">duration:1.0</div><div class="line">options:(displayingPrimary UIViewAnimationOptionTransitionFlipFromRight :</div><div class="line">UIViewAnimationOptionTransitionFlipFromLeft)</div><div class="line">completion:^(BOOL finished) &#123;</div><div class="line"></div><div class="line">if (finished)</div><div class="line">&#123;</div><div class="line">displayingPrimary = !displayingPrimary;</div><div class="line">&#125;</div><div class="line">&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意：除了交换视图之外，还需要在视图控制器中执行代码来管理主视图和辅助视图的加载和卸载。有关如何通过视图控制器加载和卸载视图的信息，可以参看<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457" target="_blank" rel="external">View Controller Programming Guide for iOS</a>。</strong></p>
</blockquote>
<h2 id="视图和视图的图层一起动画更改"><a href="#视图和视图的图层一起动画更改" class="headerlink" title="视图和视图的图层一起动画更改"></a>视图和视图的图层一起动画更改</h2><p>应用程序可以根据需要自由地混合基于视图和基于图层的动画代码，但配置动画参数的过程取决于谁拥有图层。更改视图拥有的图层与更改视图本身相同，并且应用于图层属性的任何动画都根据当前基于视图的动画块的动画参数来执行。自定义图层对象会忽略基于视图的动画块参数，而是使用默认的Core Animation参数。</p>
<p>如果要为所创建的图层自定义动画参数，则必须直接使用Core Animation。通常，使用Core Animation动画化图层需要创建一个<code>CABasicAnimation</code>对象或者<code>CAAnimation</code>的其他子类对象，然后将该动画对象添加到相应的图层。</p>
<p>以下代码实现了一个动画，其同时修改一个视图和一个自定义图层。视图在其边界的中心包含一个自定义<code>CALayer</code>对象。动画顺时针旋转视图，同时逆时针旋转图层。由于旋转方向相反，图层相对于屏幕保持其原始角度，看上去并没有旋转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:1.0</div><div class="line">delay:0.0</div><div class="line">options:UIViewAnimationOptionCurveLinear</div><div class="line">animations:^&#123;</div><div class="line"></div><div class="line">// Animate the first half of the view rotation.</div><div class="line">CGAffineTransform  xform = CGAffineTransformMakeRotation(DEGREES_TO_RADIANS(-180));</div><div class="line">backingView.transform = xform;</div><div class="line"></div><div class="line">// Rotate the embedded CALayer in the opposite direction.</div><div class="line">CABasicAnimation*    layerAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];</div><div class="line">layerAnimation.duration = 2.0;</div><div class="line">layerAnimation.beginTime = 0; //CACurrentMediaTime() + 1;</div><div class="line">layerAnimation.valueFunction = [CAValueFunction functionWithName:kCAValueFunctionRotateZ];</div><div class="line">layerAnimation.timingFunction = [CAMediaTimingFunction</div><div class="line">functionWithName:kCAMediaTimingFunctionLinear];</div><div class="line">layerAnimation.fromValue = [NSNumber numberWithFloat:0.0];</div><div class="line">layerAnimation.toValue = [NSNumber numberWithFloat:DEGREES_TO_RADIANS(360.0)];</div><div class="line">layerAnimation.byValue = [NSNumber numberWithFloat:DEGREES_TO_RADIANS(180.0)];</div><div class="line">[manLayer addAnimation:layerAnimation forKey:@&quot;layerAnimation&quot;];</div><div class="line"></div><div class="line">&#125;completion:^(BOOL finished)&#123;</div><div class="line">// Now do the second half of the view rotation.</div><div class="line">[UIView animateWithDuration:1.0</div><div class="line">delay:0.0</div><div class="line">options:UIViewAnimationOptionCurveLinear</div><div class="line">animations:^&#123;</div><div class="line"></div><div class="line">CGAffineTransform  xform = CGAffineTransformMakeRotation(DEGREES_TO_RADIANS(-359));</div><div class="line">backingView.transform = xform;</div><div class="line"></div><div class="line">&#125;completion:^(BOOL finished)&#123;</div><div class="line"></div><div class="line">backingView.transform = CGAffineTransformIdentity;</div><div class="line">&#125;];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意：也可以在基于视图的动画块之外创建并应用<code>CABasicAnimation</code>对象，以获得相同的结果。所有的动画最终都依靠Core Animation来执行。因此，如果动画几乎被同时提交，它们就会一起执行。</strong></p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>对应用程序用户界面的操作必须在主线程上执行，也就是说必须在主线程中执行<code>UIView</code>类的方法。创建视图对象不一定要放在主线程，但其他所有操作都应该在主线程上进行。</strong></p>
<p>自定义打印输出视图信息，可以实现<code>drawRect:forViewPrintFormatter:</code>方法。有关如何支持打印输出视图的详细信息，可以参看<a href="https://developer.apple.com/library/content/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010156" target="_blank" rel="external">Drawing and Printing Guide for iOS</a>。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>示例代码下载地址：<a href="https://github.com/zhangshijian/UIViewDemo" target="_blank" rel="external">https://github.com/zhangshijian/UIViewDemo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/04/手势识别相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/04/手势识别相关/" itemprop="url">手势识别相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-04T21:59:04+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/04/手势识别相关/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/04/手势识别相关/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>手势识别器是处理视图中的触摸或者按压事件最简单的方法，我们可以在任意视图上附加一个或多个手势识别器。手势识别器封装了处理和解释该视图的触摸事件所需的所有逻辑，并将其与已知模式进行匹配。当触摸事件与已知模式匹配时，手势识别器会通知其关联的目标对象进行处理。手势识别器使用<code>target-action</code>设计模式去发送通知，如下图所示。当<code>UITapGestureRecognizer</code>对象在视图中检测到单指轻敲时，会调用视图所属的视图控制器的操作方法来回应。</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/0c8c5e29-c846-4a16-988b-3d809eafbb6b.png" alt="图1-1 手势识别器通知其关联到目标对象"></p>
<p>手势识别器有两种类型：离散型和连续型。当识别出手势后，<strong>离散型手势识别器</strong>只会调用一次其关联目标对象的操作方法。<strong>连续型手势识别器</strong>则可能会多次调用其关联目标对象的操作方法，包括手势的开始和结束以及跟踪手势细节的变化。例如，使用拖拽手势识别器时，只要触摸事件的位置发生变化，<code>UIPanGestureRecognizer</code>对象就会调用其关联对象的操作方法。</p>
<h2 id="配置手势识别器"><a href="#配置手势识别器" class="headerlink" title="配置手势识别器"></a>配置手势识别器</h2><p>配置手势识别器分为以下三步：</p>
<ul>
<li>使用代码创建一个手势识别器对象，并将其附加到视图上。或者，使用<code>storyboard</code>，直接将手势识别器拖动到视图上。</li>
<li>实现识别手势后目标对象要调用的操作方法。</li>
<li>调用手势识别器对象的<code>addTarget:action:</code>方法将目标对象和目标对象要调用的操作方法与手势识别器关联起来。或者，使用<code>storyboard</code>，右键单击手势识别器将其<strong>Sent Action selector</strong>连接到目标对象来创建关联操作方法。</li>
</ul>
<h2 id="回应手势"><a href="#回应手势" class="headerlink" title="回应手势"></a>回应手势</h2><p>与手势识别器关联的操作方法为应用程序提供了对该手势的响应。对于离散型手势，其关联的操作方法与按钮的操作方法类似。只有手势识别成功后，才会调用其关联对象的操作方法作出响应。对于连续型手势，其关联的操作方法不仅可以对手势识别成功后作出响应，还可以在识别手势之前跟踪手势细节的变化。</p>
<p>手势识别器的<code>state</code>属性可以反映当前的手势识别状态。对于连续型手势，手势识别器会在手势识别过程中将此属性值从<code>UIGestureRecognizerStateBegan</code>变更为<code>UIGestureRecognizerStateChanged</code>，手势被识别后变更为<code>UIGestureRecognizerStateEnded</code>。</p>
<h3 id="点击手势"><a href="#点击手势" class="headerlink" title="点击手势"></a>点击手势</h3><p>点击手势识别器<code>UITapGestureRecognizer</code>对象会简要地检测一个或多个手指点击屏幕。<strong>在点击手势被识别成功前</strong>，涉及手势的手指不能从初始触摸点<strong>显著移动</strong>到其他地方，但可以配置手指必须触摸屏幕的次数。例如，可以配置点击手势识别器来检测单击，双击或者三击。</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/14d1769c-c081-4c4a-9466-e5dca8a2e053.png" alt="图3-1 Tap gestures"></p>
<p>点击手势属于离散型手势，只有当点击手势识别成功后才会调用其关联对象的操作方法。由于手势可以被取消的原因有很多，所以在操作方法中回应手势前，检查<code>state</code>属性可以确保不会出错。</p>
<p>如果触摸屏幕后没有调用与手势识别器关联的对象的操作方法，请检查下列条件是否成立：</p>
<ul>
<li>视图的<code>userInteractionEnabled</code>属性设置为<code>YES</code>。<code>UIImageView</code>和<code>UILabel</code>类默认将此属性设为<code>NO</code>。</li>
<li>点击次数等于<code>numberOfTapsRequired</code>属性中指定的次数。</li>
<li>手指个数等于<code>numberOfTouchesRequired</code>属性中指定的个数。</li>
</ul>
<h3 id="长按手势"><a href="#长按手势" class="headerlink" title="长按手势"></a>长按手势</h3><p>长按手势识别器<code>UILongPressGestureRecognizer</code>对象检测一个或者多个手指长时间触摸屏幕。<strong>在长按手势被识别成功前</strong>，涉及手势的手指不能从初始触摸点<strong>显著移动</strong>到其他地方，但可以配置手指必须触摸屏幕的次数以及长按手势的最短持续时间。手势识别器仅由触摸的持续时间而不是与其相关的力触发。</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/c57fc4b9-4419-4ef9-9067-d27f474504af.png" alt="图3-2 Long-press gesture"></p>
<p>长按手势根据触摸的持续时间来确定手势的成功或者失败，它属于连续型手势，手势关联对象的操作方法可能会随着手势状态的变化而被多次调用。长按手势识别器在用户手指停留在屏幕上一定时间后(用户手指仍旧停留在屏幕上)进入<code>UIGestureRecognizerStateBegan</code>状态，当触摸事件更新时，进入<code>UIGestureRecognizerStateChanged</code>状态，用户手指离开屏幕时，进入<code>UIGestureRecognizerStateEnded</code>状态。</p>
<p>如果触摸屏幕后没有调用与手势识别器关联的对象的操作方法，请检查下列条件是否成立：</p>
<ul>
<li>视图的<code>userInteractionEnabled</code>属性设置为<code>YES</code>。<code>UIImageView</code>和<code>UILabel</code>类默认将此属性设为<code>NO</code>。</li>
<li>点击次数等于<code>numberOfTapsRequired</code>属性中指定的次数。</li>
<li>手指个数等于<code>numberOfTouchesRequired</code>属性中指定的个数。</li>
<li>触摸持续时间大于<code>minimumPressDuration</code>属性中指定的时间。</li>
</ul>
<h3 id="拖拽手势"><a href="#拖拽手势" class="headerlink" title="拖拽手势"></a>拖拽手势</h3><p>拖拽手势识别器<code>UIPanGestureRecognizer</code>对象检测一个或者多个手指在屏幕上移动。屏幕边缘拖拽手势是限定触摸位置在屏幕边缘的拖拽手势，使用<code>UIScreenEdgePanGestureRecognizer</code>对象来识别屏幕边缘拖拽手势。</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/92edf0c4-8d94-469b-b81d-c00a20e74f5e.png" alt="图3-3 Pan gesture"></p>
<p>拖拽手势属于连续型手势，在手势识别过程中，会多次调用手势关联对象的操作方法。当手指开始移动时，拖拽手势识别器进入<code>UIGestureRecognizerStateBegan</code>状态，继续移动会导致手势识别器进入<code>UIGestureRecognizerStateChanged</code>状态。当手指离开屏幕时，进入<code>UIGestureRecognizerStateEnded</code>状态。</p>
<p>使用<code>UIPanGestureRecognizer</code>对象的<code>translationInView:</code>方法可以获取手指从初始触摸位置移动的距离。在手势开始时，拖拽手势识别器会存储初始触摸点。如果手势涉及多个手指，则手势识别器会使用多个手指的触摸点的中心点。</p>
<p>如果触摸屏幕后没有调用与手势识别器关联的对象的操作方法，请检查下列条件是否成立：</p>
<ul>
<li>视图的<code>userInteractionEnabled</code>属性设置为<code>YES</code>。<code>UIImageView</code>和<code>UILabel</code>类默认将此属性设为<code>NO</code>。</li>
<li>触摸次数在<code>minimumNumberOfTouches</code>和<code>maximumNumberOfTouches</code>属性中指定的值之间。</li>
<li>如果是屏幕边缘拖拽手势，应确保触摸位置在<code>edges</code>属性中指定的区域中。</li>
</ul>
<h3 id="轻扫手势"><a href="#轻扫手势" class="headerlink" title="轻扫手势"></a>轻扫手势</h3><p>轻扫手势识别器<code>UISwipeGestureRecognizer</code>对象检测屏幕上一个或多个手指在特定的水平或垂直方向上移动。轻扫手势的方向和手指的数量是可以配置的，其属于离散型手势，只有在手势被成功识别后才会调用手势关联对象的操作方法。当我们只关注手势的结果而不关注手指的移动时，轻扫手势是最合适的。</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/7fa694cb-f654-4f71-a653-ea908b5bb27c.png" alt="图3-4 Swipe gesture"></p>
<p>如果触摸屏幕后没有调用与手势识别器关联的对象的操作方法，请检查下列条件是否成立：</p>
<ul>
<li>视图的<code>userInteractionEnabled</code>属性设置为<code>YES</code>。<code>UIImageView</code>和<code>UILabel</code>类默认将此属性设为<code>NO</code>。</li>
<li>触摸次数等于<code>numberOfTouchesRequired</code>属性中指定的值之间。</li>
<li>滑动的方向与<code>direction</code>属性值相匹配。</li>
</ul>
<h3 id="捏合手势"><a href="#捏合手势" class="headerlink" title="捏合手势"></a>捏合手势</h3><p>捏合手势属于连续型手势，其跟踪最先触摸屏幕的两根手指之间的距离，使用<code>UIPinchGestureRecognizer</code>对象来检测捏合手势。</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/46733a3e-1a59-4ca3-acb3-dc14958374a7.png" alt="图3-5 Pinch gestures"></p>
<p>当两个手指间的距离开始改变时，会更新捏合手势识别器对象的手指间当前距离与初始距离的比例<code>scale</code>属性值，然后调用手势关联目标对象的操作方法。捏合手势常用于更改屏幕上的对象或者内容的大小。<strong>在缩放内容大小时，应该取<code>scale</code>值和内容初始大小的积。</strong></p>
<p>如果触摸屏幕后没有调用与手势识别器关联的对象的操作方法，请检查下列条件是否成立：</p>
<ul>
<li>视图的<code>userInteractionEnabled</code>属性设置为<code>YES</code>。<code>UIImageView</code>和<code>UILabel</code>类默认将此属性设为<code>NO</code>。</li>
<li>至少两根手指同时触摸屏幕。</li>
<li>正在使用<code>scale</code>值缩放内容大小。</li>
</ul>
<h3 id="旋转手势"><a href="#旋转手势" class="headerlink" title="旋转手势"></a>旋转手势</h3><p>旋转手势属于连续型手势，其跟踪触摸屏幕的两根手指旋转的角度，使用<code>UIRotationGestureRecognizer</code>对象来检测旋转手势。</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/0d8b92d2-dbfc-4316-97fd-aa2f6ee22db3.png" alt="图3-6 Rotation gesture"></p>
<p>当手指开始在屏幕上旋转时，会更新旋转手势识别器对象的从初始到现在已旋转角度<code>rotation</code>属性值，然后调用手势关联目标对象的操作方法。可以使用旋转手势来旋转视图或者更新自定义控件的值。</p>
<p>如果触摸屏幕后没有调用与手势识别器关联的对象的操作方法，请检查下列条件是否成立：</p>
<ul>
<li>视图的<code>userInteractionEnabled</code>属性设置为<code>YES</code>。<code>UIImageView</code>和<code>UILabel</code>类默认将此属性设为<code>NO</code>。</li>
<li>至少两根手指同时触摸屏幕。</li>
<li>正在使用<code>rotation</code>旋转内容。</li>
</ul>
<h2 id="处理手势冲突"><a href="#处理手势冲突" class="headerlink" title="处理手势冲突"></a>处理手势冲突</h2><p>在视图上附加多个手势识别器时，多个手势识别器会同时跟踪传入的触摸事件。但<strong>默认</strong>情况下UIKit只允许在单个视图中一次只识别一个手势，也就是说当某个手势识别器成功识别手势后，其他手势识别器就不会再继续去识别该手势。一次只识别一个手势可以防止用户一次触发多个动作，但这种<strong>默认</strong>识别行为可能会导致意想不到的副作用。例如，在包含拖拽和轻扫手势识别器的视图中，轻扫手势永远不会被识别。这是因为拖拽手势是连续的，所以它总是在轻扫手势之前被识别。</p>
<p>UIKit通过调用手势识别器的委托对象的代理方法来确定一个手势是否必须在其他手势之前或之后被识别，或者两个手势是否可以被同时识别。对于涉及潜在冲突的两个手势识别器，只需要其中一个手势识别器去关联委托对象，该委托对象需要遵循<code>UIGestureRecognizerDelegate</code>协议。</p>
<h3 id="确定在视图中识别手势的顺序"><a href="#确定在视图中识别手势的顺序" class="headerlink" title="确定在视图中识别手势的顺序"></a>确定在视图中识别手势的顺序</h3><p>当视图上附加有单击和双击手势时，单击手势会始终在双击手势之前被识别，但是可以通过实现单击手势委托对象的<code>gestureRecognizer:shouldRequireFailureOfGestureRecognizer:</code>方法去延后单击手势的识别直到双击手势被识别失败，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer</div><div class="line">&#123;</div><div class="line">if (gestureRecognizer == self.singleTap &amp;&amp; otherGestureRecognizer == self.doubleTap)</div><div class="line">&#123;</div><div class="line">return YES;</div><div class="line">&#125;</div><div class="line">return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当视图上附加有轻扫和拖拽手势时，拖拽手势会始终在轻扫手势之前被识别。在这种情况下，可以通过实现轻扫手势委托对象的<code>gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:</code>方法实现在识别轻扫手势失败后才识别拖拽手势，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer</div><div class="line">&#123;</div><div class="line">if (gestureRecognizer == self.swip &amp;&amp; otherGestureRecognizer == self.pan)</div><div class="line">&#123;</div><div class="line">return YES;</div><div class="line">&#125;</div><div class="line">return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以通过实现拖拽手势委托对象的<code>gestureRecognizer:shouldRequireFailureOfGestureRecognizer:</code>方法去延后拖拽手势的识别直到轻扫手势被识别失败，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer</div><div class="line">&#123;</div><div class="line">if (gestureRecognizer == self.pan &amp;&amp; otherGestureRecognizer == self.swip)</div><div class="line">&#123;</div><div class="line">return YES;</div><div class="line">&#125;</div><div class="line">return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="允许同时识别多个手势"><a href="#允许同时识别多个手势" class="headerlink" title="允许同时识别多个手势"></a>允许同时识别多个手势</h3><p>在默认情况下，UIkit在单个视图中一次只允许识别一个手势，但如果有需要，也可以在单个视图中同时识别多个手势。要允许在单个视图中同时识别多个手势，需要手势委托对象实现<code>gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:</code>方法。UIKit会调用此方法来判断是否允许同时识别两个手势，默认返回<code>NO</code>。</p>
<p>当一个视图上同时附加有拖拽、 缩放和旋转手势时，允许用户在屏幕上可以同时拖动、 缩放和旋转视图，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer</div><div class="line">&#123;</div><div class="line">// 允许同时识别在同一视图上的特定手势</div><div class="line">if (gestureRecognizer.view == self.targetView &amp;&amp; otherGestureRecognizer.view == self.targetView)</div><div class="line">&#123;</div><div class="line">// 排除长按手势</div><div class="line">if (![gestureRecognizer isMemberOfClass:[UILongPressGestureRecognizer class]] &amp;&amp; ![otherGestureRecognizer isMemberOfClass:[UILongPressGestureRecognizer class]])</div><div class="line">&#123;</div><div class="line">return YES;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>要同时识别多个手势，它们的委托对象都要实现<code>gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:</code>方法，如果只有其中一个手势的委托对象实现了，但其它手势的委托对象没有实现，那么UIKit也不会同时识别它们。</strong></p>
<h2 id="自定义手势识别器"><a href="#自定义手势识别器" class="headerlink" title="自定义手势识别器"></a>自定义手势识别器</h2><p>当UIKit定义的手势类型不能满足我们需求时，我们也可以自定义手势识别器来处理特定的触摸事件。自定义手势识别器的详情可以参看<a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer" target="_blank" rel="external">Implementing a Custom Gesture Recognizer</a></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>示例代码下载地址：<a href="https://github.com/zhangshijian/GesturesDemo.git" target="_blank" rel="external">https://github.com/zhangshijian/GesturesDemo.git</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/04/导航栏颜色、透明度渐变/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/04/导航栏颜色、透明度渐变/" itemprop="url">导航栏颜色、透明度渐变</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-04T21:57:54+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/04/导航栏颜色、透明度渐变/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/04/导航栏颜色、透明度渐变/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发过程中，经常会碰到控制器对应的导航栏的背景颜色不一致或者需要让导航栏背景透明的需求。在导航控制器push和pop视图控制器的过程中，直接修改导航栏背景色在视觉上会显得比较突兀。为了给用户更好的使用体验，就需要为导航栏的背景色和透明度变换添加一种合适的动画效果。</p>
<h2 id="UINavigationBar基础"><a href="#UINavigationBar基础" class="headerlink" title="UINavigationBar基础"></a>UINavigationBar基础</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>导航栏是<code>UINavigationBar</code>类的实例对象，是一个显示在窗口的顶部并包含用于在屏幕层次结构内进行导航的按钮的栅栏。导航栏最常用于导航控制器中，导航控制器对象创建、显示和管理导航栏，并使用导航控制器管理的视图控制器的相关属性来控制导航栏中显示的内容。</p>
<p><img src="https://docs-assets.developer.apple.com/published/dde7452123/3abba22e-4aef-47dd-b4e2-a9965c424338.png" alt="图2-1"></p>
<p>使用导航控制器控制导航栏时，需要执行以下步骤：</p>
<ul>
<li>在<strong>Interface Builder</strong>或代码中创建一个导航控制器。</li>
<li>使用<code>UINavigationController</code>对象的<code>navigationBar</code>属性配置导航栏的外观。</li>
<li>通过设置导航控制器堆栈中管理的每个视图控制器的<code>title</code>和<code>navigationItem</code>属性来控制导航栏的内容。</li>
</ul>
<p>也可以单独使用导航栏，将导航栏添加到界面中时需要执行以下步骤：</p>
<ul>
<li>设置自动布局规则来管理界面中导航栏的位置。</li>
<li>创建一个<strong>root navigationItem</strong>来提供初始标题。</li>
<li>配置委托对象来处理与导航栏的交互。</li>
<li>自定义导航栏的外观。</li>
<li>配置应用程序界面，以便用户在浏览分层屏幕时推入和弹出相关<code>navigationItem</code>。</li>
</ul>
<h3 id="导航栏和导航控制器配合使用"><a href="#导航栏和导航控制器配合使用" class="headerlink" title="导航栏和导航控制器配合使用"></a>导航栏和导航控制器配合使用</h3><p>使用导航控制器来管理不同内容屏幕之间的导航时，导航控制器会自动创建导航栏，并在适当的时间推入和弹出<code>navigationItem</code>。</p>
<p>在视图控制器出栈和入栈时，导航控制器使用此视图控制器对象的<code>navigationItem</code>属性为其导航栏提供当前需要显示的内容。默认的<code>navigationItem</code>使用视图控制器的标题，但可以通过覆盖<code>UIViewController</code>子类的<code>navigationItem</code>属性来完全控制导航栏内容。</p>
<p>导航控制器会自动将其自身指定为其导航栏对象的委托对象，所以在使用导航控制器时，不要将导航栏的委托对象设置为自定义对象。</p>
<p>要访问与导航控制器关联的导航栏，请使用<code>UINavigationController</code>对象的<code>navigationBar</code>属性。</p>
<p>有关导航控制器的信息，可以参看<a href="https://developer.apple.com/documentation/uikit/uinavigationcontroller" target="_blank" rel="external">UINavigationController</a>。</p>
<h3 id="添加视图到单独使用的导航栏"><a href="#添加视图到单独使用的导航栏" class="headerlink" title="添加视图到单独使用的导航栏"></a>添加视图到单独使用的导航栏</h3><p>在绝大多数场景中，导航栏都是作为导航控制器的一部分使用的。但是有些情况下可能需要单独使用导航栏来实现内容导航方法。单独使用导航栏时，需要为其提供内容。与其他类型的视图不同，不能直接将子视图添加到导航栏，而需要使用<code>navigationItem</code>来指定要显示的按钮或者自定义视图。<code>navigationItem</code>是<code>UINavigationItem</code>类的实例对象，其持有用于在导航栏的左侧、右侧和中心指定视图以及用于指定自定义提示字符串的属性，如图2-1所示。</p>
<p>导航栏管理着一个包含<code>UINavigationItem</code>对象的堆栈。堆栈主要用于支持导航控制器，可以使用它来实现我们自己的自定义导航界面。堆栈中最顶端的<code>navigationItem</code>是导航栏当前显示内容所属的<code>navigationItem</code>，使用其<code>pushNavigationItem:animated:</code>方法将新的<code>navigationItem</code>推入到堆栈中，使用<code>popNavigationItemAnimated:</code>方法从堆栈中弹出<code>navigationItem</code>。</p>
<p>除了推入和弹出<code>navigationItem</code>之外，还可以直接使用导航栏的<code>items</code>属性或者<code>setItems:animated:</code>方法设置堆栈的内容。可以在应用程序启动时使用此方法将界面恢复到上次关闭应用程序前的状态。下图显示了导航栏是如何管理<code>navigationItem</code>堆栈的：</p>
<p><img src="https://docs-assets.developer.apple.com/published/dde7452123/536711f8-0b4b-4ecd-a086-3b8c6feb1a6c.png" alt="图2-2"></p>
<p>单独使用导航栏时，需要手动为导航栏配置委托对象，委托对象要遵循<code>UINavigationBarDelegate</code>协议。通过实现委托对象的委托方法，委托对象就能接收到导航栏发送的消息。这样就能跟踪何时推入<code>navigationItem</code>到堆栈中或者从堆栈中弹出<code>navigationItem</code>，并根据这些消息来更新应用程序的界面。</p>
<p>有关创建<code>navigationItem</code>的信息，可以参看<a href="https://developer.apple.com/documentation/uikit/uinavigationitem" target="_blank" rel="external">UINavigationItem</a>。有关委托对象的信息，可以参看<a href="https://developer.apple.com/documentation/uikit/uinavigationbardelegate" target="_blank" rel="external">UINavigationBarDelegate</a>。</p>
<h3 id="自定义导航栏外观"><a href="#自定义导航栏外观" class="headerlink" title="自定义导航栏外观"></a>自定义导航栏外观</h3><p>导航栏有两种标准的外观样式：黑色文字配白色背景或者白色文字配黑色背景。使用其<code>barStyle</code>属性来配置外观样式。对导航栏外观样式<code>barStyle</code>属性的更改，会覆盖导航栏从其他与外观有关的属性推断出的显示内容。</p>
<p>导航栏默认是半透明的，可以通过将其<code>translucent</code>属性值设为<code>NO</code>来使导航栏不透明。</p>
<p>可以使用<code>barTintColor</code>属性来设置导航栏背景色，设置此属性会覆盖从<code>barStyle</code>属性推断出的默认颜色。与所有<code>UIView</code>子类一样，可以使用<code>tintColor</code>属性来控制导航栏上控件内容的颜色，包括按钮图片和按钮文字。</p>
<p><code>titleTextAttributes</code>属性用来指定标题文本外观的，可以分别使用<code>NSFontAttributeName</code>、<code>NSForegroundColorAttributeName</code>和<code>NSShadowAttributeName</code>键为标题文本指定字体、文本颜色、文本阴影颜色和文本阴影偏移量。</p>
<p>使用<code>setTitleVerticalPositionAdjustment:forBarMetrics:</code>方法来调整标题在垂直方向上的位置，<code>UIBarMetrics</code>枚举值定义了导航栏是否紧凑和是否含有提示文本，该方法会根据指定的<code>UIBarMetrics</code>枚举值来调整导航栏的高度。下图显示了具有自定义的背景颜色、标题文本属性和控件内容颜色的导航栏。</p>
<p><img src="https://docs-assets.developer.apple.com/published/dde7452123/e8608c12-1a29-47c9-95c5-984a0ca17bce.png" alt="图2-3"></p>
<p>还可以提供自定义背景图片和阴影图片来完全定制导航栏的外观，调用<code>setBackgroundImage:forBarPosition:barMetrics:</code>方法根据指定的<code>UIBarPosition</code>枚举值和<code>UIBarMetrics</code>枚举值来设置对应导航栏的背景图片。<code>UIBarPosition</code>枚举值定义了导航栏是在窗口底部还是在窗口顶部显示的。</p>
<p>通过配置<code>shadowImage</code>属性值来为导航栏提供自定义阴影图片，但是自定义阴影图片的前提条件是必须要自定义导航栏背景图片。否则，将会使用默认的阴影图片。下图显示了自定义背景图片并自定义阴影图片的导航栏，导航栏的位置值为<code>UIBarPositionTopAttached</code>，高度值为<code>UIBarMetricsDefault</code>。</p>
<p><img src="https://docs-assets.developer.apple.com/published/dde7452123/01969d1a-db6b-4ef5-b86b-45ffa1730b85.png" alt="图2-4"></p>
<h2 id="导航栏颜色、透明度渐变"><a href="#导航栏颜色、透明度渐变" class="headerlink" title="导航栏颜色、透明度渐变"></a>导航栏颜色、透明度渐变</h2><p>应用程序在iOS 10以上系统运行时，使用Xcode调试应用程序时，查看半透明导航栏的视图层，其子视图信息如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4906302-1fd037493eaf0883.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3-1"></p>
<p>如果导航栏不透明，视图层就不会包含UIVisualEffectView视图分支。如果导航栏使用了自定义背景，则会插入一个<code>UIImageView</code>视图到<code>_UIBarBackground</code>视图并位于最底层。另外，在iOS 10以下的系统中运行时，UIVisualEffectView子视图层中的视图会有所改变。</p>
<p>导航栏的外观是由其<code>_UIBarBackground</code>子视图决定的。调用官方提供的方法设置导航栏背景色时，实际调整的是<code>_UIBarBackground</code>子视图的背景颜色，调用官方提供的方法设置导航栏自定义背景图片时，实际上是在<code>_UIBarBackground</code>子视图的最底层添加一个<code>UIImageView</code>视图。</p>
<h3 id="调整导航栏颜色"><a href="#调整导航栏颜色" class="headerlink" title="调整导航栏颜色"></a>调整导航栏颜色</h3><p>在视图控制器跳转过程中，实时调用官方提供的方法<strong>动态改变</strong>导航栏的背景色，有可能会遇到一些问题。这是因为官方在视图控制器跳转过程中，在内部也会对导航栏执行一些操作，我们对导航栏的操作可能会被覆盖掉。所以，为了能够完全控制导航栏的背景色操作，可以在<code>_UIBarBackground</code>子视图最底层手动添加一个子视图，并通过改变这个子视图的背景来控制导航栏的外观背景，这样就不会被官方的操作覆盖掉。</p>
<h3 id="调整导航栏透明度"><a href="#调整导航栏透明度" class="headerlink" title="调整导航栏透明度"></a>调整导航栏透明度</h3><p>官方没有提供方法来直接修改导航栏的透明度，但我们已经知道导航栏的外观由其<code>_UIBarBackground</code>子视图决定。所以，调整<code>_UIBarBackground</code>视图及其子视图的透明度就能改变导航栏的透明度。</p>
<h3 id="视图控制器push或pop过程中导航栏背景颜色和透明度渐变"><a href="#视图控制器push或pop过程中导航栏背景颜色和透明度渐变" class="headerlink" title="视图控制器push或pop过程中导航栏背景颜色和透明度渐变"></a>视图控制器push或pop过程中导航栏背景颜色和透明度渐变</h3><p>对视图控制器执行push或者pop操作时，为了提高用户体验，通常会使用官方提供的转场动画。官方提供的转场动画有交互式和非交互式两种类型。在执行push或者pop操作时，两个视图控制器的对应导航栏背景色不同，直接修改背景色在视觉上会显得很突兀。这时候，就需要给导航栏背景色的切换加上动画效果，让其随着push或者pop转场动画一起执行。</p>
<p>侧滑返回时，执行的是交互式转场动画。要对导航栏背景色和透明度执行动画切换，就需要在转场动画执行过程中实时得知转场动画执行进度。虽然官方没有公开提供获取转场动画执行进度的方法，但是其却包含一个<code>_updateInteractiveTransition:</code>私有方法能够实时获取转场动画执行进度。我们可以在运行时使用方法交换在官方实现内部操作的同时，顺便改变导航栏的背景色和透明度。这样，导航栏颜色和透明度切换动画就能随转场动画一起执行了。</p>
<p>直接调用官方提供的方法来执行push或pop操作时，执行的是非交互式转场动画。对于非交互式转场<br>动画，是无法获取到执行进度的，但转场动画上下文对象提供了<code>animateAlongsideTransition:completion:</code>和<code>animateAlongsideTransitionInView:animation:completion:</code>方法来让我们在转场动画执行过程中对其他视图执行动画。<code>animateAlongsideTransition:completion:</code>方法可以在转场过程中对包含在转场动画容器视图中的子视图执行动画操作，<code>animateAlongsideTransitionInView:animation:completion:</code>方法可以在转场过程中对其他任何视图执行动画操作。由于无法得知转场动画执行的进度，所以使用此方法来对导航栏的背景颜色执行渐变动画是无效的。而手动模拟计算转场动画执行进度，并根据这个模拟进度来执行动画有点儿繁琐且效果不是太好。所以，在执行非交互式动画时，采用了跟随转场动画push或者pop切换两种背景颜色的方式。笔者在实现导航栏背景颜色的push或者pop切换动画时，取了个巧，就是在插入到导航栏底部的视图上，再添加一个子视图，在转场动画执行过程中，该视图和子视图的背景色分别为两个控制器对应导航栏的背景色，然后对子视图执行位移动画。转场动画执行完毕后，再将两个视图的背景色设为一致，具体代码可参看Demo。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>示例代码下载地址：<a href="https://github.com/zhangshijian/UINavigationBarDemo" target="_blank" rel="external">https://github.com/zhangshijian/UINavigationBarDemo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/05/响应者、响应者链和事件处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/05/响应者、响应者链和事件处理/" itemprop="url">响应者、响应者链和事件处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-05T12:08:21+08:00">
                2016-07-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/07/05/响应者、响应者链和事件处理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/07/05/响应者、响应者链和事件处理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>应用程序使用响应者对象来接收和处理事件，属于<code>UIResponder</code>类的实例对象都是响应者，常见的子类包括<code>UIView</code>、<code>UIViewController</code>和<code>UIApplication</code>。响应者接收到原始事件后，必须处理该事件或者将此事件转发给另一个响应者。当应用程序接收到一个事件时，UIKit会自动将该事件指向最合适的响应者对象，此响应者称为第一响应者，第一响应者会将未处理的事件传递给处于激活状态的响应者链中的的下一个响应者对象。应用程序中不存在单一的响应者链，UIkit定义了如何将对象从一个响应者传递到下一个响应者的默认规则，我们可以随时通过覆盖响应者对象中的<code>nextResponder</code>属性来更改这些规则。下图显示了应用程序中的默认响应者链，其界面包含一个label，一个text field，一个button和两个background view。如果text field没有处理触摸事件，UIKit会将事件发送到text field的父视图对象，如果事件还是未被处理，UIKit会继续发送该事件到此视图的父视图，直到发送到window的根视图，然后响应者链从根视图转移到持有此根视图的视图控制器，再从视图控制器转移到window。如果window不处理这个事件，UIKit会将事件传递给<code>UIApplication</code>对象。如果应用程序的委托对象是<code>UIResponder</code>类的实例并且响应者链中还不包含该对象，那么UiKit可能将该事件传递给应用程序的委托对象。</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/f17df5bc-d80b-4e17-81cf-4277b1e0f6e4.png" alt="图1-1"></p>
<h2 id="确定事件的第一响应者"><a href="#确定事件的第一响应者" class="headerlink" title="确定事件的第一响应者"></a>确定事件的第一响应者</h2><p>对于每种类型的事件，UIKit都会指定一个第一响应者，并首先将事件发送给该对象，第一响应者根据事件的类型而有所不同：</p>
<ul>
<li>触摸事件(Touch events)：第一响应者是触摸点所在的视图。</li>
<li>按压事件(Press events)：第一响应者是有焦点的响应者。</li>
<li>摇晃运动事件(Shake-motion events)：第一响应者是由我们自己(或者UIKit)指定为第一响应者的对象。</li>
<li>远程控制事件(Remote-control events)：第一响应者是由我们自己(或者UIKit)指定为第一响应者的对象。</li>
<li>编辑菜单消息(Editing menu messages)：第一响应者是由我们自己(或者UIKit)指定为第一响应者的对象。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：与加速计、陀螺仪和磁力计相关的运动事件不遵循响应者链，Core Motion会将这些事件直接传递给我们指定的对象。有关更多信息，可以参看<a href="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/CoreServicesLayer/CoreServicesLayer.html#//apple_ref/doc/uid/TP40007898-CH10-SW27" target="_blank" rel="external">Core Motion Framework</a>。</p>
</blockquote>
<p>控件使用动作消息直接与其关联的目标对象进行通信。当用户与控件交互时，控件会调用其<code>target</code>对象的<code>action</code>方法——换句话说，控件会向目标对象发送一个动作消息。动作消息不属于事件，但是它也可以使用响应者链。当控件的<code>target</code>对象为<code>nil</code>时，UIKit会从<code>target</code>对象开始顺着响应链寻找，直到找到实现了对应<code>action</code>方法的对象。例如，编辑菜单就使用这种方式去搜索实现了方法名为<code>cut:</code>、<code>copy:</code>、<code>paste:</code>的响应者对象。</p>
<p>如果一个视图附加有手势识别器，手势识别器会先于视图接收到触摸和按压事件。如果所有视图的手势识别器都无法识别它们的手势，那么事件就会被传递给视图进行处理。如果视图没有处理它们，UIKit会继续沿着响应者链传递事件。有关使用手势识别器处理事件的更多信息，可以参看<a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures" target="_blank" rel="external">Handling UIKit Gestures</a>。</p>
<h2 id="更改响应者链"><a href="#更改响应者链" class="headerlink" title="更改响应者链"></a>更改响应者链</h2><p>可以通过覆写响应者对象的<code>nextResponder</code>属性来更改响应者链，许多UIKit类已经覆盖此属性并返回了特定的对象。</p>
<ul>
<li><code>UIView</code>对象：如果这个视图是视图控制器的根视图，那么下一个响应者就是这个视图控制器；否则，下一个响应者就是它的父视图。</li>
<li><code>UIViewController</code>对象：如果视图控制器的视图是window的根视图，则下一个响应者就是window；如果视图控制器是被另一个视图控制器呈现的，则下一个响应者是这个呈现视图控制器。</li>
<li><code>UIWindow</code>对象：window的下一个响应者是<code>UIApplication</code>对象。</li>
<li><code>UIApplication</code>对象：当应用程序的委托对象是<code>UIResponder</code>类的实例，而不是视图、视图控制器或者应用程序对象本身时，其下一个响应者就是应用程序的委托对象。</li>
</ul>
<h2 id="触摸事件-Touch-events"><a href="#触摸事件-Touch-events" class="headerlink" title="触摸事件(Touch events)"></a>触摸事件(Touch events)</h2><h3 id="如何确定触摸事件的第一响应者"><a href="#如何确定触摸事件的第一响应者" class="headerlink" title="如何确定触摸事件的第一响应者"></a>如何确定触摸事件的第一响应者</h3><p>触摸事件的第一响应者是触摸位置所在的视图，UIKit使用基于视图的命中测试来确定触摸事件发生的位置。具体来说，UIKit将触摸位置与视图层中的视图对象的边界进行比较。<code>UIView</code>的<code>hitTest:withEvent:</code>方法会遍历视图层，寻找包含指定触摸位置的最深的子视图，这个视图就会成为触摸事件的第一响应者。</p>
<p><code>hitTest:withEvent:</code>方法会遍历当前视图层，并调用每个子视图的<code>pointInside:withEvent:</code>方法来判断子视图的边界是否包含触摸点。如果<code>pointInside:withEvent:</code>方法返回<code>YES</code>，则会同样遍历子视图的视图层，直到找到包含触摸点的最上层视图。如果视图不包含该触摸点，那么此视图层分支会被忽略掉。因此，我们可以通过覆写<code>hitTest:withEvent:</code>方法来隐藏子视图中的触摸事件。此方法会忽略掉被隐藏、已禁用用户交互或者<code>alpha</code>小于<strong>0.01</strong>的视图对象。在确定命中视图时，此方法不会考虑视图的内容。因此，即使触摸点位于该视图内容的透明部分，仍然可以确定命中此视图。当视图的<code>clipsToBounds</code>的属性为<code>NO</code>时，如果触摸点在视图的边界之外，即使它的子视图恰好包含该触摸点，但子视图超出了视图的边界，<code>hitTest:withEvent:</code>方法也不会返回命中了此视图。</p>
<p>UIKit会将每个触摸事件永久指定给包含触摸位置的最上层视图，当触摸开始时，UIKit会为每个触摸事件创建一个<code>UITouch</code>对象，直到触摸结束之后才会释放<code>UITouch</code>对象。随着触摸位置或其他参数的改变，UIKit会使用新信息更新<code>UITouch</code>对象，唯一不变的属性是触摸事件所属的<code>view</code>。即使触摸位置移动到触摸事件所属的原始视图之外，触摸事件所属视图也不会改变。</p>
<h3 id="回应触摸事件"><a href="#回应触摸事件" class="headerlink" title="回应触摸事件"></a>回应触摸事件</h3><p>响应者对象都是<code>UIResponder</code>类的实例，在处理特定类型的事件时，系统会调用响应者对象相应的方法去回应事件，响应者必须覆写实现相应的方法。为了处理触摸事件，响应者对象需要实现<code>touchesBegan:withEvent:</code>、<code>touchesMoved:withEvent:</code>和<code>touchesEnded:withEvent:</code>方法中的一个或者多个。UIKit确定触摸事件的第一响应者之后，如果这个响应者类覆写实现了<code>touchesBegan:withEvent:</code>、<code>touchesMoved:withEvent:</code>和<code>touchesEnded:withEvent:</code>方法中的一个或者多个，那么当触摸开始发生时，系统会调用响应者对象的<code>touchesBegan:withEvent:</code>方法去回应触摸事件。当触摸位置移动时，会调用响应者对象的<code>touchesMoved:withEvent:</code>方法去回应，当触摸结束时，会调用<code>touchesEnded:withEvent:</code>方法去回应。如果这几个方法一个都没有被实现，那么UIKit会沿着默认的响应者链去传递触摸事件。如果响应者链中有响应者实现了前述方法，那么该响应者对象就会去处理传递来的触摸事件。否则，该触摸事件就不会被处理。</p>
<p>系统还可以随时取消正在进行的触摸序列，当有来电打断应用程序时，UIKit会调用响应者的<code>touchesCancelled:withEvent:</code>方法去通知响应者当前触摸事件已经被系统取消了。</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/08b952fe-6f46-41eb-8b8a-4830c1d48842.png" alt="图4-1 触摸事件的阶段"></p>
<p><code>touchesBegan:withEvent:</code>、<code>touchesMoved:withEvent:</code>、<code>touchesEnded:withEvent:</code>和<code>touchesCancelled:withEvent:</code>方法分别对应于触摸事件处理过程的不同阶段。当手指(或Apple Pencil)触摸屏幕时，UIKit会创建一个<code>UITouch</code>对象，将触摸点设置为相应的屏幕坐标点，并将其<code>phase</code>属性值设为<code>UITouchPhaseBegan</code>。当手指在屏幕上移动时，UIKit会更新触摸位置，并将<code>UITouch</code>对象的<code>phase</code>属性值改变为<code>UITouchPhaseMoved</code>。当用户从屏幕上移开手指时，UIKit会将<code>phase</code>属性值改变为<code>UITouchPhaseEnded</code>，触摸序列结束。当触摸事件被系统取消时，UIKit会将<code>phase</code>属性值改变为<code>UITouchPhaseCancelled</code>。</p>
<blockquote>
<p><strong>重要</strong>：在默认配置下，当多个手指同时触摸视图时，视图也只会接收与事件关联的第一个<code>UITouch</code>对象。要接收额外的触摸事件，必须将视图的<code>multipleTouchEnabled</code>属性设为<code>YES</code>。</p>
</blockquote>
<h2 id="摇晃-运动事件-Shake-motion-events"><a href="#摇晃-运动事件-Shake-motion-events" class="headerlink" title="摇晃-运动事件(Shake-motion events)"></a>摇晃-运动事件(Shake-motion events)</h2><p>当系统监听到摇晃事件时，会寻找摇晃事件的第一响应者，并将该摇晃事件传递给第一响应者去处理，而摇晃事件的第一响应者是被我们自己(或者UIKit)指定为第一响应者的对象。覆写响应者对象的<code>canBecomeFirstResponder</code>方法并返回<code>YES</code>，同时调用其<code>becomeFirstResponder</code>方法，该响应者对象就会被指定为第一响应者。要对摇晃事件进行处理，响应者对象还需要至少覆写实现<code>motionBegan:withEvent:</code>和<code>motionEnded:withEvent:</code>方法中的一个。当摇晃事件开始发生时，系统会调用响应者对象的<code>motionBegan:withEvent:</code>方法去回应摇晃事件。当摇晃事件结束时，系统会调用响应者对象的<code>motionEnded:withEvent:</code>方法回应。如果第一响应者没有处理，那么UIKit会沿着响应者链传递该摇晃事件。</p>
<p>当我们不需要再对摇晃事件进行处理时，需要调用当前响应者对象的<code>resignFirstResponder</code>方法注销其第一响应者身份。</p>
<p><strong>注意：本人在iOS 11(11以下系统未试)下通过代码实践发现，按照上述步骤指定第一响应对象后，响应者对象并未接收到摇晃事件。当系统监听到摇晃事件时，UIKit直接将该摇晃事件发送给当前视图控制器，如果当前视图控制器覆写实现了<code>motionBegan:withEvent:</code>和<code>motionEnded:withEvent:</code>方法，那么当前视图控制器就会去处理该摇晃事件。如果没有，这个事件就不会被应用程序处理。</strong></p>
<h2 id="远程控制事件-Remote-control-events"><a href="#远程控制事件-Remote-control-events" class="headerlink" title="远程控制事件(Remote-control events)"></a>远程控制事件(Remote-control events)</h2><p>远程控制事件主要是由耳机线控操作触发的，它和音频播放有关。远程控制事件有以下几种类型：</p>
<ul>
<li><code>UIEventSubtypeRemoteControlPlay</code>：播放事件，在暂停状态下，按耳机线控中间按钮一下触发。</li>
<li><code>UIEventSubtypeRemoteControlPause</code>：暂停事件，在播放状态下，按耳机线控中间按钮一下触发。</li>
<li><code>UIEventSubtypeRemoteControlStop</code>：停止事件</li>
<li><code>UIEventSubtypeRemoteControlTogglePlayPause</code>：播放或暂停切换，在播放或暂停状态下，按耳机线控中间按钮一下触发。</li>
<li><code>UIEventSubtypeRemoteControlNextTrack</code>：下一曲，按耳机线控中间按钮两下触发。</li>
<li><code>UIEventSubtypeRemoteControlPreviousTrack</code>：上一曲，按耳机线控中间按钮三下触发。</li>
<li><code>UIEventSubtypeRemoteControlBeginSeekingBackward</code>：快退开始，按耳机线控中间按钮三下不要松开触发。</li>
<li><code>UIEventSubtypeRemoteControlEndSeekingBackward</code>：快退停止，按耳机线控中间按钮三下到了快退的位置松开触发。</li>
<li><code>UIEventSubtypeRemoteControlBeginSeekingForward</code>：快进开始，按耳机线控中间按钮两下不要松开触发。</li>
<li><code>UIEventSubtypeRemoteControlEndSeekingForward</code>：快进停止，按耳机线控中间按钮两下到了快进的位置松开触发。</li>
</ul>
<p>接收远程控制事件首先需要在应用程序启动完成后调用应用程序中唯一的<code>UIApplication</code>对象的<code>beginReceivingRemoteControlEvents</code>方法启用远程控制事件接收。要对远程控制事件进行处理，需要响应者对象覆写实现<code>remoteControlReceivedWithEvent:</code>方法，如果这个响应者对象不是<code>UIApplication</code>类或者<code>UIViewController</code>类的实例，还需要指定该响应者对象为第一响应者。要停止接收远程控制事件，需要调用应用程序中唯一的<code>UIApplication</code>对象的<code>endReceivingRemoteControlEvents</code>方法。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>示例代码下载：<a href="https://github.com/zhangshijian/EventHandlingDemo.git" target="_blank" rel="external">https://github.com/zhangshijian/EventHandlingDemo.git</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/06/05/UICollectionView探究/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/05/UICollectionView探究/" itemprop="url">UICollectionView探究</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-05T22:08:21+08:00">
                2016-06-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/06/05/UICollectionView探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/06/05/UICollectionView探究/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;<a href="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CollectionViewBasics/CollectionViewBasics.html#//apple_ref/doc/uid/TP40012334-CH2-SW7" target="_blank" rel="external">UICollectionView</a>是iOS开发中最常用的UI控件之一，可以用它来管理一组有序的不同尺寸的视图，并以可定制的布局来展示它们。UICollectionView支持动画，当视图被插入，删除或重新排序时，会触发动画，动画效果支持自定义。为了更好的使用UICollectionView，我们有必要对其进行深入了解。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="UICollectionView是由多个对象协作实现的"><a href="#UICollectionView是由多个对象协作实现的" class="headerlink" title="UICollectionView是由多个对象协作实现的"></a>UICollectionView是由多个对象协作实现的</h3><p>&emsp;&emsp;集合视图将视图的数据内容与视图的布局方式分开来管理。数据内容由集合视图的dataSource对象管理，而布局方式则是由许多不同的对象协作来管理。下表列出了UIKit中与集合视图相关的类，并根据它们在集合视图中的作用进行了划分。</p>
<table>
<thead>
<tr>
<th>目的</th>
<th>类/协议</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>顶层容器和管理者</td>
<td>UICollectionView UICollectionViewController</td>
<td>UICollectionView定义了显示视图内容的空间，它继承自<a href="https://developer.apple.com/documentation/uikit/uiscrollview" target="_blank" rel="external">UIScrollView</a>，能够根据内容的高度来调整其滚动区域。它的layout布局对象会提供布局信息来呈现数据。UICollectionViewController对象提供了一个UICollectionView的视图控制器级管理支持。</td>
</tr>
<tr>
<td>内容管理</td>
<td>UICollectionViewDataSource协议 UICollectionViewDelegate协议</td>
<td>DataSource协议是必须实现的，它创造并管理UICollectionView的视图内容。Delegate协议能获取视图的信息并自定义视图的行为，这个协议是可选实现的。</td>
</tr>
<tr>
<td>内容视图</td>
<td>UICollectionReusableView UICollectionViewCell</td>
<td>UICollectionView展示的所有视图都必须是UICollectionReusableView类的实例，该类支持回收复用机制。在视图滚动时,回收复用视图而不是重新创建，能极大提高性能。UICollectionViewCell对象是用来展示主要数据的可重用视图,该类继承自UICollectionReusableView。</td>
</tr>
<tr>
<td>布局</td>
<td>UICollectionViewLayout UICollectionViewLayoutAttributes UICollectionViewUpdateItem</td>
<td>UICollectionViewLayout的子类被称为布局对象，它负责定义集合视图中的cell和可重用视图的位置，大小，视觉效果。在布局过程中，布局对象UICollectionViewLayout会创建一个布局属性对象UICollectionViewLayoutAttributes去告诉集合视图在什么位置，用什么样视觉外观去展示cell和可重用视图。当在集合视图中插入，删除，移动数据项时，布局对象会接收到UICollectionViewUpdateItem类的实例，我们不需要自行创建该类的实例。</td>
</tr>
<tr>
<td>流水布局</td>
<td>UICollectionViewFlowLayout UICollectionViewDelegateFlowLayout协议</td>
<td>UICollectionViewFlowLayout类是用于实现网格或其他基于行的布局的具体布局对象。 我们可以按照原样使用该类或者配合UICollectionViewDelegateFlowLayout协议一起使用，这样就可以动态自定义布局信息。</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;集合视图从<code>dataSource</code>对象中获取要展示的cell的数据内容，通过<code>delegate</code>对象去管理cell的选中和高亮等状态。布局对象负责决定cell所在的位置，布局属性对象记录了cell的布局属性，布局对象将布局属性对象传递给集合视图，集合视图接收到布局属性信息后创建并展示cell。</p>
<p><img src="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Art/cv_objects_2x.png" alt="图1-1"></p>
<h3 id="重用视图提高性能"><a href="#重用视图提高性能" class="headerlink" title="重用视图提高性能"></a>重用视图提高性能</h3><p>&emsp;&emsp;集合视图通过复用已被回收的cell来提高效率，当cell滚动到屏幕外时，它们不会被销毁，但会被移出容器视图并放置到重用队列中。当有新的内容将要滚动到屏幕中时，如果重用队列中有可复用的cell，会首先从重用队列中取，并重置被取出来的cell的数据，然后将其添加到容器视图中展示。如果重用队列没有可复用的cell，这时才会新创建一个cell去展示。为了方便这种循环，集合视图中展示的都必须继承自<code>UICollectionReusableView</code>类。</p>
<p>&emsp;&emsp;集合视图支持三种不同类型的可重用视图，每种视图都具有特定的用途：</p>
<ul>
<li>cell(单元格)展示集合视图的主要内容，每个cell展示的内容由<code>dataSource</code>对象提供。每个cell都必须是<code>UICollectionViewCell</code>的实例，同时我们也可以根据需要对其子类化。cell对象支持管理其选中和高亮状态。</li>
<li>supplementary view(补充视图)展示每个section(分区)的信息。和cell相同的是：supplementary view也是数据驱动的。不同的是：supplementary view是可选的而不是强制的。supplementary view的使用和布局是由布局对象管理的，系统提供的流水布局支持设置header和footer作为可选的supplementary view。</li>
<li>decoration view(装饰视图)与<code>dataSource</code>对象提供的数据不相关，完全属于布局对象。布局对象可能会使用它自定义集合视图背景。</li>
</ul>
<h3 id="布局对象控制视图的视觉效果"><a href="#布局对象控制视图的视觉效果" class="headerlink" title="布局对象控制视图的视觉效果"></a>布局对象控制视图的视觉效果</h3><p>&emsp;&emsp;布局对象负责确定集合视图中每个cell的位置和视觉样式。虽然<code>dataSource</code>对象提供了要展示的视图和实际内容，但布局对象确定了这些视图的位置，大小以及其他与外观相关的属性。这种责任划分使得我们能够在动态的更改布局时无需更改<code>dataSource</code>对象提供的数据。</p>
<p>&emsp;&emsp;布局对象并不拥有任何视图，它只会生成用来描述cell，supplementary view和decoration view的位置，大小，视觉样式的布局属性，并将布局属性传递给集合视图，集合视图将这些属性应用于实际的视图对象。</p>
<p>&emsp;&emsp;布局对象可以随意生成视图的位置，大小以及视觉样式属性，没有任何限制。只有布局对象能改变视图在集合视图中的位置，它能移动视图，也能随机切换横竖屏，甚至能复位某视图而不用考虑此视图周围的视图。例如，如果有需要，布局对象可以将所有视图叠加在一起。</p>
<p>&emsp;&emsp;下图显示了垂直滚动的流水布局对象如何布置cell。在垂直滚动流水布局中，内容区域的宽度保持固定，高度随着内容高度的增加而增加。布局对象一次只放置一个cell，在放置前会先计算出cell在容器视图中的frame，为cell选择最合适的位置。</p>
<p><img src="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Art/cv_layout_basics_2x.png" alt="图1-2"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>&emsp;&emsp;必须为集合视图提供一个<code>dataSource</code>对象，集合视图从<code>dataSource</code>对象中获取要显示的内容。它可以是一个数据模型对象，也可以是管理集合视图的视图控制器，<code>dataSource</code>对象的唯一要求是它必须能够提供集合视图所需的所有信息。<code>delegate</code>对象是可选的，用于管理与内容的呈现以及交互有关的方面。它的主要职责是管理cell的选中和高亮状态，可以扩展<code>UICollectionViewDelegate</code>协议以提供其他信息。流水布局对象就扩展了<code>UICollectionViewDelegate</code>协议来定制布局，例如，cell的大小和它们之间的间距。</p>
<h3 id="UICollectionViewDataSource"><a href="#UICollectionViewDataSource" class="headerlink" title="UICollectionViewDataSource"></a>UICollectionViewDataSource</h3><p>提供集合视图包含的section(分区)数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView*)collectionView</div><div class="line">&#123;</div><div class="line">return [_dataArray count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>提供每个section包含的item(单元格)数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)collectionView:(UICollectionView*)collectionView numberOfItemsInSection:(NSInteger)section</div><div class="line">&#123;</div><div class="line">NSArray* sectionArray = [_dataArray objectAtIndex:section];</div><div class="line"></div><div class="line">return [sectionArray count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据IndexPath提供对应的cell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">UICollectionViewCell* cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;reuseIdentifier&quot; forIndexPath:indexPath];</div><div class="line"></div><div class="line">return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据IndexPath提供对应的supplementary view，流水布局的supplementary view分为Header和Footer两种类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">// UICollectionElementKindSectionHeader返回Header，UICollectionElementKindSectionFooter返回Footer</div><div class="line">if ([kind isEqualToString:UICollectionElementKindSectionHeader])</div><div class="line">&#123;</div><div class="line">UICollectionReusableView *supplementaryView = [collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:@&quot;HeaderReuseIdentifier&quot; forIndexPath:indexPath];</div><div class="line"></div><div class="line">return supplementaryView;</div><div class="line">&#125;else</div><div class="line">&#123;</div><div class="line">UICollectionReusableView *supplementaryView = [collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:@&quot;FooterReuseIdentifier&quot; forIndexPath:indexPath];</div><div class="line"></div><div class="line">return supplementaryView;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：当集合视图展示的cell数量较少时，集合视图的<code>bounce</code>属性会默认关闭，而有时候我们的页面需要下拉刷新数据的功能，这时只需要设置<code>alwaysBounceVertical</code>属性设为<code>YES</code>即可。</p>
</blockquote>
<h3 id="UICollectionViewDelegate"><a href="#UICollectionViewDelegate" class="headerlink" title="UICollectionViewDelegate"></a>UICollectionViewDelegate</h3><p>设置cell是否能被选中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当集合视图的<code>allowsMultipleSelection</code>多选属性为<code>YES</code>时，设置是否可以点击取消选中已被选中的cell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>已选中cell后回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>已取消选中cell后回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置cell被选中时是否支持高亮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>选中cell时触发高亮后回调，我们可以在这里去改变cell的背景色:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class="line"></div><div class="line">cell.contentView.backgroundColor = [UIColor lightGrayColor];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>cell被取消选中变为普通状态后回调，我们可以在这里还原cell的背景色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class="line"></div><div class="line">cell.contentView.backgroundColor = [UIColor whiteColor];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：点击cell时，cell的状态变化过程为：手指接触屏幕时，cell状态变为高亮，此时cell还未被选中。当手指离开屏幕后，cell状态变回到普通状态，然后cell被集合视图选中。当快速点击选中cell时，由于状态变化很快，导致人眼看不出来cell背景色有发生变化，实际上是发生了变化的。而长按选中cell时，可以看到背景色的变化。</p>
</blockquote>
<p><img src="http://oaz007vqv.bkt.clouddn.com/cell_selection_semantics_2x.png?imageView/2/w/600" alt="图2-1"></p>
<h3 id="UICollectionViewDelegateFlowLayout"><a href="#UICollectionViewDelegateFlowLayout" class="headerlink" title="UICollectionViewDelegateFlowLayout"></a>UICollectionViewDelegateFlowLayout</h3><p>该协议是对<code>UICollectionViewDelegate</code>的扩展，能够动态返回cell的大小，和cell之间的最小间距等。</p>
<p>根据IndexPath返回对应的Cell的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">return CGSizeMake(80.0, 80.0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回cell到所在section的四周边界的距离：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section</div><div class="line">&#123;</div><div class="line">return UIEdgeInsetsMake(10.0, 10.0, 10.0, 10.0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据Section返回对应的cell之间的行最小间距：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section</div><div class="line">&#123;</div><div class="line">return 10.0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据section返回对应的cell之间的列最小间距：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section</div><div class="line">&#123;</div><div class="line">return 10.0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据section返回对应的Header大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section</div><div class="line">&#123;</div><div class="line">return CGSizeMake(collectionView.frame.size.width, 40.0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据section返回对应的Footer大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section</div><div class="line">&#123;</div><div class="line">return CGSizeMake(collectionView.frame.size.width, 40.0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="cell和supplementary-view的重用"><a href="#cell和supplementary-view的重用" class="headerlink" title="cell和supplementary view的重用"></a>cell和supplementary view的重用</h3><p>&emsp;&emsp;视图的重用避免了不断生成和销毁对象的操作，提高了程序运行的效率。要想重用cell和supplementary view，首先需要注册cell和supplementary view，有种三种注册方式：</p>
<ul>
<li>使用storyboard布局时，直接拖拽cell或者supplementary view到storyboard中，设置好重用标识即可。</li>
<li>使用xib布局时，设置重用标识后，使用<code>registerNib:forCellWithReuseIdentifier:</code>方法来注册cell，使用<code>registerNib:forSupplementaryViewOfKind:withReuseIdentifier:</code>方法来注册supplementary view。</li>
<li>使用代码布局时，使用<code>registerClass:forCellWithReuseIdentifier:</code>方法来注册cell，使用<code>registerClass:forSupplementaryViewOfKind:withReuseIdentifier:</code>方法来注册supplementary view。</li>
</ul>
<blockquote>
<p> 注意：使用纯代码自定义cell和supplementary view时，需要重写<code>initWithFrame:</code>方法，<code>init</code>方法不会被调用。</p>
</blockquote>
<p>&emsp;&emsp;<code>dataSource</code>对象为集合视图配置cell和supplementary view时，使用<code>dequeueReusableCellWithReuseIdentifier:forIndexPath:</code>方法直接从重用队列中取cell，使用<code>dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:</code>方法直接从重用队列中取supplementary view。当重用队列中没有可复用的视图时，会自动帮我们新创建一个可用的视图。</p>
<h3 id="cell的插入，删除和移动"><a href="#cell的插入，删除和移动" class="headerlink" title="cell的插入，删除和移动"></a>cell的插入，删除和移动</h3><p>&emsp;&emsp;插入，删除，移动单个cell或者某个section的所有cell时，遵循下面两个步骤：</p>
<ul>
<li>更新数据源对象中的数据内容。</li>
<li>调用对应的插入，删除或者移动方法。</li>
</ul>
<p>&emsp;&emsp;集合视图插入，删除和移动cell之前，必须先对应更新数据源。如果数据源没有更新，程序运行就会崩溃。当插入，删除或者移动cell时，会自动添加动画效果来反映集合视图的更改。在执行动画时，如果还需要<code>同步</code>执行其他操作，可以使用<code>performBatchUpdates:completion:</code>方法，在<code>updates block</code>内执行所有插入，删除或移动调用，动画执行完毕后会调用<code>completion block</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[self.collectionView performBatchUpdates:^&#123;</div><div class="line">// 执行更改操作</div><div class="line"></div><div class="line">&#125; completion:^(BOOL finished)&#123;</div><div class="line"></div><div class="line">if (finished)</div><div class="line">&#123;</div><div class="line">// 执行其他操作</div><div class="line">&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h3 id="长按cell弹出编辑菜单"><a href="#长按cell弹出编辑菜单" class="headerlink" title="长按cell弹出编辑菜单"></a>长按cell弹出编辑菜单</h3><p>&emsp;&emsp;长按某个cell时，可以弹出一个编辑菜单，能够用于剪切，粘贴，复制这个cell。长按弹出编辑菜单，<code>delegate</code>对象必须实现下面3个委托方法：</p>
<p>是否显示编辑菜单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以执行哪些操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender</div><div class="line">&#123;</div><div class="line">if ([NSStringFromSelector(action) isEqualToString:@&quot;copy:&quot;]|| [NSStringFromSelector(action) isEqualToString:@&quot;paste:&quot;])</div><div class="line">&#123;</div><div class="line">return YES;</div><div class="line">&#125;</div><div class="line">return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>点击菜单中选项后回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender</div><div class="line">&#123;</div><div class="line">if ([NSStringFromSelector(action) isEqualToString:@&quot;cut:&quot;])</div><div class="line">&#123;</div><div class="line">// 剪切操作</div><div class="line">&#125;else if ([NSStringFromSelector(action) isEqualToString:@&quot;copy:&quot;])</div><div class="line">&#123;</div><div class="line">// 复制操作</div><div class="line">&#125;else if ([NSStringFromSelector(action) isEqualToString:@&quot;paste:&quot;])</div><div class="line">&#123;</div><div class="line">// 粘贴操作</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;集合视图只支持<code>cut:</code>，<code>copy:</code>，<code>paste:</code>三种编辑操作。想要了解如何配合剪贴板使用这些操作，可以参看<a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009542" target="_blank" rel="external">Text Programming Guide for iOS</a>。</p>
<h3 id="切换布局时的转场动画"><a href="#切换布局时的转场动画" class="headerlink" title="切换布局时的转场动画"></a>切换布局时的转场动画</h3><p>&emsp;&emsp;切换布局最简单的方式是使用<code>setCollectionViewLayout:animated:</code>方法。在<code>UICollectionViewController</code>之间跳转时，如果需要交互式转场切换布局或者控制切换过程，可以使用<code>UICollectionViewTransitionLayout</code>对象。</p>
<p>&emsp;&emsp;<code>UICollectionViewTransitionLayout</code>类是一种特殊的布局类，它继承自<code>UICollectionViewLayout</code>类,在切换到新布局的过程中，它将作为集合视图的临时布局。使用<code>UICollectionViewTransitionLayout</code>布局对象时，可以使用不同的计时算法让动画遵循非线性路径，或者根据传入的触摸事件进行移动。官方提供的<code>UICollectionViewTransitionLayout</code>类支持对新布局的线性转换，但我们可以对其进行子类化来实现任何所需的效果。</p>
<p>&emsp;&emsp;<code>UICollectionViewLayout</code>提供了几种跟踪布局之间转换进度的方法，<code>UICollectionViewTransitionLayout</code>类通过<code>transitionProgress</code>属性来跟踪转场切换的进度，当转场切换开始后，我们需要定期更新此属性值来指示完成的百分比。使用自定义<code>UICollectionViewTransitionLayout</code>对象时，<code>UICollectionViewTransitionLayout</code>类提供来2种跟踪与布局相关的值的方法：<code>updateValue:forAnimatedKey:</code>和<code>valueForAnimatedKey:</code>。</p>
<p>&emsp;&emsp;转场切换布局时，使用<code>UICollectionViewTransitionLayout</code>对象的步骤如下：</p>
<ul>
<li>使用<code>initWithCurrentLayout:nextLayout:</code>方法创建一个<code>UICollectionViewTransitionLayout</code>实例对象。</li>
<li>定期修改<code>transitionProgress</code>属性值来指示转场切换的进度。在修改转场进度后，一定要调用<code>invalidateLayout</code>方法来废弃当前布局并更新布局。</li>
<li>集合视图的<code>delegate</code>对象实现委托方法<code>collectionView:transitionLayoutForOldLayout:newLayout:</code>返回创建的<code>UICollectionViewTransitionLayout</code>实例对象。</li>
<li>可以使用<code>updateValue:forAnimatedKey:</code>方法来修改与布局相关的值。</li>
</ul>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="流水布局"><a href="#流水布局" class="headerlink" title="流水布局"></a>流水布局</h3><p>&emsp;&emsp;官方提供的<code>UICollectionViewFlowLayout</code>流水布局对象实现了基于行的断开布局，单元格被放置在线性路径上，并沿着该行放置尽可能多的单元格，当前行上的空间在使用最小间距也不足以放置下一个单元格时，会重新计算出合适的当前行上摆放的单元格之间的间距，如果该行上只有一个单元格，那么它会被置中，然后会创建新的一行并在该行重复之前的布局过程。</p>
<p><img src="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Art/flow_horiz_layout_uneven_2x.png" alt="图3-1"></p>
<p><img src="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Art/flow_section_insets_2x.png" alt="图3-2"></p>
<p>&emsp;&emsp;使用时，通过固定单元格的大小和单元格之间的最小间距来实现网格状视图，同时也可以任意设置单元格的小和单元格之间的间距来实现不规则排列的视图。当单元格的大小，单元格之间的最小间距，单元格到所在分区四周的边距以及Header和Footer的大小固定时，可以直接设置<code>itemSize</code>，<code>minimumLineSpacing</code>，<code>minimumInteritemSpacing</code>，<code>sectionInset</code>，<code>headerReferenceSize</code>，<code>footerReferenceSize</code>属性值。如果想要动态设置它们，需要集合视图的delegate对象实现<code>UICollectionViewDelegateFlowLayout</code>协议的委托方法。</p>
<h3 id="自定义布局"><a href="#自定义布局" class="headerlink" title="自定义布局"></a>自定义布局</h3><h4 id="理解布局过程"><a href="#理解布局过程" class="headerlink" title="理解布局过程"></a>理解布局过程</h4><p>&emsp;&emsp;子类化<code>UICollectionViewLayout</code>实现自定义布局有两个关键任务需要完成：</p>
<ul>
<li>指定可滚动内容区域的大小。</li>
<li>为每个单元格和补充视图提供布局属性对象以便集合视图定位。</li>
</ul>
<p>&emsp;&emsp;集合视图和自定义布局对象一起工作来管理整体布局过程，当集合视图需要用到布局信息时，它会请求布局对象提供这些布局信息。调用布局对象的<code>invalidateLayout</code>方法会告知集合视图显式更新其布局，此方法会废弃现有的布局属性，并强制布局对象生成新的布局属性。</p>
<p>&emsp;&emsp;不要将布局对象的<code>invalidateLayout</code>方法与集合视图的<code>reloadData</code>方法混淆，调用<code>invalidateLayout</code>方法不一定会移除当前现有的单元格和子视图，它只会强制布局对象重新计算移动、添加或删除单元格时所需的所有布局信息。如果数据源对象提供的数据发生了更改，则应该调用<code>reloadData</code>方法。使用这两种方法来更新布局时，实际的布局过程都是一样的。</p>
<p>&emsp;&emsp;在布局过程中，集合视图会始终按顺序来调用布局对象的以下三种方法：</p>
<ul>
<li><code>- (void)prepareLayout</code></li>
<li><code>- (CGSize)collectionViewContentSize</code></li>
<li><code>- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect</code></li>
</ul>
<p>&emsp;&emsp;集合视图调用布局对象的<code>prepareLayout</code>方法，提供机会让我们提前计算确定布局属性信息时所需的数据，从计算出来的数据中要能够得知集合视图整个内容区域的大小。</p>
<p>&emsp;&emsp;集合视图调用布局对象的<code>collectionViewContentSize</code>方法获得内容大小来适当的配置其滚动视图，我们在这里根据提前计算的数据返回整个内容区域的大小。如果内容大小在垂直和水平方向上都超出当前设备屏幕的边界，则会允许滚动视图同时在这两个方向上滚动，而<code>UICollectionViewFlowLayout</code>只能在一个方向上滚动。</p>
<p>&emsp;&emsp;集合视图会基于当前的滚动位置调用<code>layoutAttributesForElementsInRect:</code>方法来查找在特定区域中的单元格和视图的布局属性，此区域和可视区域可能相同也可能不同，我们在这里遍历提前生成的所有的布局属性信息，检查每个布局信息的frame，返回所有frame和给定rect相交的布局属性，这样核心布局过程就完成了。</p>
<p><img src="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Art/cv_layout_process_2x.png" alt="图4-1"></p>
<p>&emsp;&emsp;我们可以在<code>prepareLayout</code>方法中生成布局属性对象后缓存起来，也可以在<code>layoutAttributesForElementsInRect:</code>方法中生成布局属性对象，但是集合视图在滚动过程中会多次调用<code>layoutAttributesForElementsInRect:</code>方法，这样就会为视图重复计算布局属性，会有性能损耗。</p>
<p>&emsp;&emsp;布局完成后，单元格和视图的布局属性会保持不变。调用布局对象的<code>invalidateLayout</code>会废弃当前所有布局信息，然后再次从调用<code>prepareLayout</code>方法开始，重复布局过程生成新的布局信息。集合视图在滚动过程中，会不断调用布局对象的<code>shouldInvalidateLayoutForBoundsChange:</code>方法来判断是否需要废弃当前布局并重新生成布局。当集合视图的<code>bounds</code>属性发生变化时，也会调用<code>shouldInvalidateLayoutForBoundsChange:</code>方法。</p>
<p>&emsp;&emsp;调用<code>invalidateLayout</code>方法后不会立即开始布局更新过程，该方法仅将布局标记为与数据不一致并需要更新。在下一个视图更新周期中，集合视图会检查其布局是否为脏，如果是，则更新布局。也就是说，当我们快速连续地调用<code>invalidateLayout</code>方法多次后，不会每次调用都立即更新布局。</p>
<h4 id="创建布局信息对象"><a href="#创建布局信息对象" class="headerlink" title="创建布局信息对象"></a>创建布局信息对象</h4><p>&emsp;&emsp;官方提供了三种方法来创建<code>UICollectionViewLayoutAttributes</code>布局信息对象：</p>
<ul>
<li><code>+ (instancetype)layoutAttributesForCellWithIndexPath:(NSIndexPath *)indexPath</code></li>
<li><code>+ (instancetype)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind withIndexPath:(NSIndexPath *)indexPath</code></li>
<li><code>+ (instancetype)layoutAttributesForDecorationViewOfKind:(NSString *)decorationViewKind withIndexPath:(NSIndexPath *)indexPath</code></li>
</ul>
<p>&emsp;&emsp;要根据视图的类型调用对应的方法来生成布局属性对象，因为集合视图会根据布局信息对象的<code>representedElementCategory</code>属性从数据源对象中获取对应类型的视图，使用错误的方法生成布局信息对象会导致集合视图在错误的位置创建错误的视图。</p>
<p>&emsp;&emsp;生成布局属性对象后，一定要根据前面提前计算的数据设置好<code>frame</code>或者<code>center</code>和<code>size</code>属性，使集合视图能够确定对应的视图的位置和大小。同时，还可以设置<code>transform</code>，<code>alpha</code>，<code>hidden</code>等属性来控制对应视图的视觉效果。如果视图的布局是重叠的，则可以设置<code>zIndex</code>属性值来确保视图的顺序一致。如果官方提供<code>UICollectionViewLayoutAttributes</code>标准类无法满足需求，可以对其子类化并扩展，以存储和视图外观有关的信息。当对布局属性进行子类化时，需要实现用于比较自定义属性的<code>isEqual:</code>方法，因为集合视图对其某些操作使用此方法。</p>
<h4 id="根据需要为单个视图提供布局属性"><a href="#根据需要为单个视图提供布局属性" class="headerlink" title="根据需要为单个视图提供布局属性"></a>根据需要为单个视图提供布局属性</h4><p>&emsp;&emsp;布局对象还需要能够根据需要为单个视图提供布局属性，因为集合视图会在执行Cell的插入，删除，移动和刷新动画时请求该布局信息。需要覆写下面三种方法：</p>
<ul>
<li><code>-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath</code></li>
<li><code>-(UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath</code></li>
<li><code>-(UICollectionViewLayoutAttributes *)layoutAttributesForDecorationViewOfKind:(NSString*)elementKind atIndexPath:(NSIndexPath *)indexPath</code></li>
</ul>
<p>&emsp;&emsp;在三种方法中，需要返回已计算好的对应视图的布局属性信息，返回属性时，不应更改布局属性。如果布局中不包含任何补充视图和装饰视图，则不需要覆写后两种方法。</p>
<h4 id="自定义cell的插入，删除，移动和刷新动画"><a href="#自定义cell的插入，删除，移动和刷新动画" class="headerlink" title="自定义cell的插入，删除，移动和刷新动画"></a>自定义cell的插入，删除，移动和刷新动画</h4><p>&emsp;&emsp;集合视图调用对应的方法<code>插入</code>、<code>删除</code>、<code>刷新</code>、<code>移动</code>cell时，布局对象会调用<code>invalidateLayout</code>废弃现有的布局信息，重新执行前面提到的布局过程生成新的布局属性。在集合视图更新前调用<code>prepareForCollectionViewUpdates:</code>方法告知要更新的cell在更新前的IndexPath和更新完成后的IndexPath，以及其要执行的更新方式(插入、删除、刷新、移动)，我们需要重写此方法记录这些IndexPath。</p>
<p>&emsp;&emsp;之后，集合视图会执行两个动画：更新布局前每个cell被移除的动画和更新布局后每个cell显示的动画，我们看到的动画效果是由这两个动画组合而成的。在执行动画过程中，布局对象会调用<code>finalLayoutAttributesForDisappearingItemAtIndexPath:</code>方法获取对应IndexPath的cell被移除时的最终布局属性来执行动画：更新布局前的布局属性值–&gt;cell被移除时的最终布局属性值，调用<code>initialLayoutAttributesForAppearingItemAtIndexPath:</code>方法获取对应IndexPath的cell显示时的起始布局属性来执行动画：cell显示时的起始布局属性值–&gt;更新布局后的cell布局属性值。</p>
<p>&emsp;&emsp;<code>插入</code>、<code>删除</code>、<code>移动</code>cell时，会导致其周围cell的布局属性发生变化，这些cell会强制执行这个动画：cell更新布局前的frame–&gt;cell更新布局后的frame，这是官方在内部实现的。在重写<code>finalLayoutAttributesForDisappearingItemAtIndexPath:</code>和<code>initialLayoutAttributesForAppearingItemAtIndexPath:</code>方法设置执行动画用到的布局属性时，最好检查一下传入的IndexPathh与调用<code>prepareForCollectionViewUpdates:</code>方法时记录的IndexPath是否一致。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>&emsp;&emsp;示例代码下载：<a href="https://github.com/zhangshijian/UICollectionViewDemo" target="_blank" rel="external">https://github.com/zhangshijian/UICollectionViewDemo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="ShiJian" />
          <p class="site-author-name" itemprop="name">ShiJian</p>
           
              <p class="site-description motion-element" itemprop="description">光阴给我们经验,读书给我们知识.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhangshijian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/shijianzzzz" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShiJian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://ShiJian.disqus.com/count.js" async></script>
    

    

  




	





  





  








  





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
