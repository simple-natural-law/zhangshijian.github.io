<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="子类化视图控制器设计UI可以使用Xcode中的storyboard文件直观地定义视图控制器的UI，也可以以编程方式来创建UI。但storyboard可以将视图的内容可视化，并根据需要自定义视图层次结构。以可视化方式构建UI界面，可以让我们快速进行更改并能看到结果，而无需构建和运行应用程序。 下图显示了一个storyboard的例子。每个矩形区域代表一个视图控制器及其相关视图，视图控制器之间的箭头是">
<meta property="og:type" content="article">
<meta property="og:title" content="UIViewController详解 -- 视图控制器定义">
<meta property="og:url" content="http://yoursite.com/2017/04/15/UIViewController详解-视图控制器定义/index.html">
<meta property="og:site_name" content="ShiJian">
<meta property="og:description" content="子类化视图控制器设计UI可以使用Xcode中的storyboard文件直观地定义视图控制器的UI，也可以以编程方式来创建UI。但storyboard可以将视图的内容可视化，并根据需要自定义视图层次结构。以可视化方式构建UI界面，可以让我们快速进行更改并能看到结果，而无需构建和运行应用程序。 下图显示了一个storyboard的例子。每个矩形区域代表一个视图控制器及其相关视图，视图控制器之间的箭头是">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4906302-9c3c06ab097289a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4906302-5eab8813cf57ad4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4906302-b115a90a7f3c6f83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4906302-c3f9e3c8d772d67d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4906302-05ae784f9afe71e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4906302-5df6d24c8fc02a4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-03-19T16:06:50.355Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UIViewController详解 -- 视图控制器定义">
<meta name="twitter:description" content="子类化视图控制器设计UI可以使用Xcode中的storyboard文件直观地定义视图控制器的UI，也可以以编程方式来创建UI。但storyboard可以将视图的内容可视化，并根据需要自定义视图层次结构。以可视化方式构建UI界面，可以让我们快速进行更改并能看到结果，而无需构建和运行应用程序。 下图显示了一个storyboard的例子。每个矩形区域代表一个视图控制器及其相关视图，视图控制器之间的箭头是">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/4906302-9c3c06ab097289a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/15/UIViewController详解-视图控制器定义/"/>





  <title>UIViewController详解 -- 视图控制器定义 | ShiJian</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShiJian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/15/UIViewController详解-视图控制器定义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShiJian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShiJian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UIViewController详解 -- 视图控制器定义</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-15T00:00:12+08:00">
                2017-04-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/15/UIViewController详解-视图控制器定义/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/15/UIViewController详解-视图控制器定义/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="子类化视图控制器"><a href="#子类化视图控制器" class="headerlink" title="子类化视图控制器"></a>子类化视图控制器</h2><h3 id="设计UI"><a href="#设计UI" class="headerlink" title="设计UI"></a>设计UI</h3><p>可以使用Xcode中的storyboard文件直观地定义视图控制器的UI，也可以以编程方式来创建UI。但storyboard可以将视图的内容可视化，并根据需要自定义视图层次结构。以可视化方式构建UI界面，可以让我们快速进行更改并能看到结果，而无需构建和运行应用程序。</p>
<p>下图显示了一个storyboard的例子。每个矩形区域代表一个视图控制器及其相关视图，视图控制器之间的箭头是视图控制器的关系和节点。关系将容器视图控制器连接到其子视图控制器。Segue可用于在界面中的视图控制器之间导航。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4906302-9c3c06ab097289a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5-1"></p>
<a id="more"></a>
<h3 id="处理用户交互"><a href="#处理用户交互" class="headerlink" title="处理用户交互"></a>处理用户交互</h3><p>应用程序的响应者对象会处理传入的事件，虽然视图控制器是响应者对象，但它们很少直接处理触摸事件。相反，视图控制器通常以下列方式处理事件：</p>
<ul>
<li>视图控制器定义了处理更高级别事件的操作方法。行动方法回应：</li>
<li>具体行动。控件和一些视图调用行动方法来报告特定的交互。</li>
<li>手势识别器。手势识别器调用行动方法来报告手势的当前状态。使用视图控制器处理状态变更或响应已完成的手势。</li>
<li>视图控制器观察由系统或其他对象发出的通知，通知报告更改。通知也是视图控制器更新其状态的一种方式。</li>
<li>视图控制器充当另一个对象的数据源或委托。例如，可以将它们用作<code>CLLocationManager</code>对象的代理，该对象将更新的位置发送给其委托对象。</li>
</ul>
<h3 id="在运行时显示视图"><a href="#在运行时显示视图" class="headerlink" title="在运行时显示视图"></a>在运行时显示视图</h3><p>storyboard加载和显示视图控制器视图的过程非常简单。当需要时，UIKit会自动从stroyboard文件中加载视图。作为加载过程的一部分，UIKit执行以下任务序列：</p>
<ul>
<li>使用storyboard文件中的信息实例化视图。</li>
<li>连接所有的outlets和actions。</li>
<li>将根视图分配给视图控制器的视图属性。</li>
<li>调用视图控制器的<code>awakeFromNib</code>方法。调用此方法时，视图控制器的特征集合为空，视图可能不在其最终位置。</li>
<li>调用视图控制器的<code>viewDidLoad</code>方法。在此方法中添加或者删除视图，修改布局约束，并未视图加载数据。</li>
</ul>
<p>在屏幕上显示视图控制器的视图之前，UIKit提供了额外的机会在视图显示前后来执行需要的操作。具体来说，UIKit执行以下任务序列：</p>
<ul>
<li>在视图即将出现在屏幕上前，调用视图控制器的<code>viewWillAppear:</code>方法。</li>
<li>更新视图的布局。</li>
<li>在屏幕上显示视图。</li>
<li>视图显示后，调用视图控制器的<code>viewDidAppear:</code>方法。</li>
</ul>
<p>添加、删除或修改视图的尺寸或者位置时，也要添加和删除适用于这些视图的任何约束。对视图层次结构进行与布局相关的更改会导致UIKit将布局标记为脏。在下一个更新周期中，布局引擎使用当前布局约束条件计算视图的尺寸和位置，并将这些更改应用于视图层次结构。</p>
<h3 id="管理视图布局"><a href="#管理视图布局" class="headerlink" title="管理视图布局"></a>管理视图布局</h3><p>当视图的尺寸和位置发生变化时，UIKit将更新视图层次结构的布局信息。对于使用Auto Layout配置的视图，UIKit将使用Auto Layout引擎根据当前约束来更新布局。UIKit还会通知其他感兴趣的对象（如正在呈现的控制器）布局发生更改，以便它们可以做出相应的响应。</p>
<p>在布局过程中，UIKit会在几个时间点发出通知，以便我们可以执行其他与布局相关的任务。使用这些用纸来修改布局约束，或者在应用布局约束后对布局进行最终的调整。在布局过程中，UIKit为每个受影响的视图控制器执行以下操作：</p>
<ul>
<li>根据需要更新视图控制器及其视图的特征集合。</li>
<li>调用视图控制器的<code>viewWillLayoutSubviews</code>方法。</li>
<li>调用当前<code>UIPresentationController</code>的<code>containerViewWillLayoutSubviews</code>方法。</li>
<li>调用视图控制器的根视图的<code>layoutSubviews</code>方法。此方法默认使用可用的约束来计算新的布局信息。然后该方法遍历视图层，并调用每个子视图的<code>layoutSubviews</code>方法。</li>
<li>将计算的布局信息应用于视图。</li>
<li>调用视图控制器的<code>viewDidLayoutSubviews</code>方法。</li>
<li>调用当前<code>UIPresentationController</code>对象的<code>containerViewDidLayoutSubviews</code>方法。</li>
</ul>
<p>视图控制器可以使用<code>viewWillLayoutSubviews</code>和<code>viewDidLayoutSubviews</code>方法来执行可能影响布局过程的附加更新。在布局之前，可以添加或删除视图，更新视图的尺寸或位置，更新约束或更新其他视图相关的属性。布局之后，可以重新加载表格数据，更新其他视图的内容，或对视图的尺寸和位置进行最终调整。</p>
<h2 id="实现一个容器视图控制器"><a href="#实现一个容器视图控制器" class="headerlink" title="实现一个容器视图控制器"></a>实现一个容器视图控制器</h2><p>容器视图控制器是将多个视图控制器的内容合并到单个用户界面中的一种方法。容器视图控制器通常使导航变得容易，并基于现有内容创建新的用户界面类型。UIKit中容器视图控制器的示例包括<code>UINavigationController</code>、<code>UITabBarController</code>和<code>UISplitViewController</code>，它们都可以方便在用户界面的不同部分之间进行导航。</p>
<h3 id="设计自定义容器视图控制器"><a href="#设计自定义容器视图控制器" class="headerlink" title="设计自定义容器视图控制器"></a>设计自定义容器视图控制器</h3><p>几乎在任何情况下，容器视图控制器都像其他任何内容视图控制器一样管理根视图和一些内容。区别在于容器视图控制器从其他视图控制器获取其内容的一部分。其获取的内容仅限于其他视图控制器的视图，这些视图嵌入在其自己的根视图层次结构中。容器视图控制器设置任何嵌入视图的尺寸和位置，但原始视图控制器仍然管理这些视图内的内容。</p>
<p>在设计容器视图控制器时，需要始终了解容器和包含的视图控制器之间的关系。视图控制器的关系可以帮助告知它们的内容应该如何显示在屏幕上，以及容器如何在内部管理它们。在设计过程中，需要搞清楚以下几个问题：</p>
<ul>
<li>容器的作用是什么？其子视图控制器扮演什么样的角色？</li>
<li>多少个子视图控制器同时显示？</li>
<li>同级子视图控制器之间有什么关系（如果有的话）？</li>
<li>子视图控制器如何添加到容器或从容器中移除？</li>
<li>子视图控制器的尺寸和位置能改变吗？这些变化在什么情况下发生？</li>
<li>容器是否提供任何装饰或导航相关的视图？</li>
<li>容器视图控制器和子视图控制器之间如何通信？容器是否需要向<code>UIViewController</code>类定义的标准事件报告特定的事件？</li>
<li>容器的外观是否可以用不同的方式配置？如果可以，如何实现？</li>
</ul>
<p>在定义了各种对象的角色之后，容器视图控制器的实现相对简单。UIKit唯一的要求就是在容器视图控制器和任何子视图控制器之间建立正式的父子关系。父子关系确保子视图控制器收到任何相关的系统消息。除此之外，大部分的实际工作都是在包含视图的布局和管理过程中发生的，每个容器都是不同的。我们可以将视图放置在容器的内容区域的任何位置，然后根据需要调整视图的尺寸。还可以将自定义视图添加到视图层次结构中，以提供装饰或者辅助导航。</p>
<h3 id="示例：导航控制器"><a href="#示例：导航控制器" class="headerlink" title="示例：导航控制器"></a>示例：导航控制器</h3><p><code>UINavigationController</code>对象支持通过分层数据集来导航。导航界面一次显示一个子视图控制器。界面顶部的导航栏显示数据层次结构中当前位置，并显示后退按钮以向后移动一个级别。向下导航到另一个子视图控制器，并将子视图控制器添加到数据层次结构中。</p>
<p>视图控制器之间的导航由导航控制器及其子视图控制器共同管理。当用户与子视图控制器的按钮或表格进行交互后，子视图控制器要求导航控制器将新的视图控制器推入视图。子视图控制器处理新的视图控制器的内容的配置，但导航控制器管理转场动画。导航控制器还管理导航栏，该导航栏显示用于解除最顶层视图控制器的后退按钮。</p>
<p>下图显示了导航控制器及其视图的结构。大多数内容区域由最顶层的子视图控制器填充，只有一小部分被导航栏占用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4906302-5eab8813cf57ad4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6-1"></p>
<p>在紧凑和常规的环境下，导航控制器一次只显示一个子视图控制器。导航控制器调整其子视图控制器以适应可用空间。</p>
<h3 id="示例：分割控制器"><a href="#示例：分割控制器" class="headerlink" title="示例：分割控制器"></a>示例：分割控制器</h3><p><code>UISplitViewController</code>对象以主要-细节排列方式来显示两个视图控制器的内容。在这种排列中，一个视图控制器（主视图）的内容决定了其他视图控制器显示的细节。两个视图控制器的可见性是可配置的，但也受到当前环境的支配。在规则的水平环境中，分割视图控制器可以同时显示两个子视图控制器，或者可以隐藏主视图控制器并根据需要显示。在紧凑的环境中，分割视图控制器一次只显示一个视图控制器。</p>
<p>下图显示了在一个常规的水平环境中的分割视图界面及其视图的结构。分割视图控制器本身只有默认的容器视图。在这个例子中，两个子视图是并排显示的。子视图的尺寸是可配置的，主视图的可见性也是可配置的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4906302-b115a90a7f3c6f83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6-2"></p>
<h3 id="在Interface-Builder中配置容器"><a href="#在Interface-Builder中配置容器" class="headerlink" title="在Interface Builder中配置容器"></a>在Interface Builder中配置容器</h3><p>要在设计时创建父子容器关系，需要将一个容器视图对象添加到视图控制器中，如下图所示。容器视图对象是代表子视图控制器内容的占位符对象。使用该视图来调整和定位与容器中其他视图相关的子视图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4906302-c3f9e3c8d772d67d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6-3"></p>
<p>当使用一个或多个容器视图加载视图控制器时，Interface Builder还会加载与这些视图关联的子视图控制器。子视图控制器必须与父视图控制器同时实例化，以便建立适当的父子关系。</p>
<p>如果不使用Interface Builder来设置父 - 子容器关系，则必须通过将每个子项添加到容器视图控制器来以编程方式创建这些关系。</p>
<h3 id="实现自定义容器视图控制器"><a href="#实现自定义容器视图控制器" class="headerlink" title="实现自定义容器视图控制器"></a>实现自定义容器视图控制器</h3><p>要实现一个容器视图控制器，必须建立容器视图控制器和其子视图控制器之间的关系。在尝试管理任何子视图控制器的视图之前，建立这些父子关系是必需的。这样做让UIKit知道容器视图控制器正在管理子视图控制器的尺寸和位置。我们可以在Interface Builder中创建这些关系，或以编程方式创建它们。</p>
<h4 id="将子视图控制器添加到内容"><a href="#将子视图控制器添加到内容" class="headerlink" title="将子视图控制器添加到内容"></a>将子视图控制器添加到内容</h4><p>要以编程方式将子视图控制器合并到内容中，请执行以下操作，在相关的视图控制器之间创建父子关系：</p>
<ul>
<li>调用容器视图控制器的<code>addChildViewController:</code>方法，此方法告诉UIKit容器视图控制器现在正在管理子视图控制器的视图。</li>
<li>设置好子视图控制器内容的尺寸和位置，将子视图控制器的根视图添加到容器视图控制器的视图层次结构中。</li>
<li>添加任何约束来管理子视图控制器的根视图的尺寸和位置。</li>
<li>调用子视图控制器的<code>didMoveToParentViewController:</code>方法。</li>
</ul>
<p>以下代码展示了如何在容器视图控制器中嵌入一个子视图控制器。建立父子关系后，容器视图控制器设置其子视图控制器内容的框架，并将子视图控制器的根视图添加到自己的视图层次结构中。设置子视图控制器的根视图的尺寸很重要，能够确保视图在容器中正确显示。在添加视图之后，容器视图控制器调用子视图控制器的<code>didMoveToParentViewController:</code>方法，以使子视图控制器有机会响应视图所有权的更改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void) displayContentController: (UIViewController*) content &#123;</div><div class="line">    [self addChildViewController:content];</div><div class="line">    content.view.frame = [self frameForContentController];</div><div class="line">    [self.view addSubview:self.currentClientView];</div><div class="line">    [content didMoveToParentViewController:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>，在上面的例子中，只调用了子视图控制器的<code>didMoveToParentViewController:</code>方法。容器视图控制器的<code>addChildViewController:</code>方法只会调用子视图控制器的<code>willMoveToParentViewController:</code>方法，我们必须自己手动调用子视图控制器的<code>didMoveToParentViewController:</code>。因为只有在将子视图嵌入容器的视图层次结构中后，才能调用此方法。</p>
<p>使用自动布局时，在将子对象添加到容器的视图层次结构后，在容器和子对象之间设置约束。添加的约束只会影响子视图控制器的根视图的尺寸和位置。请勿直接更改子视图层次结构中的根视图或任何其他视图的内容。</p>
<h4 id="移除子视图控制器"><a href="#移除子视图控制器" class="headerlink" title="移除子视图控制器"></a>移除子视图控制器</h4><p>要从容器视图控制器中删除子视图控制器，可以通过执行以下操作来删除视图控制器之间的父子关系：</p>
<ul>
<li>调用子视图控制器的<code>willMoveToParentViewController:</code>方法且传入的值为<code>nil</code>。</li>
<li>删除为子视图控制器的根视图配置的约束。</li>
<li>从容器视图控制器的视图层中移除该子视图控制器的根视图。</li>
<li>调用子视图控制器的<code>removeFromParentViewController</code>方法来结束父子关系。</li>
</ul>
<p>删除子视图控制器会永久切断容器视图控制器与子视图控制器之间的关系。只有当不再需要引用子视图控制器时，才能移除子视图控制器。例如，当一个新视图控制器推入导航堆栈时，导航控制器并不会移除当前的子视图控制器。只有当它们从堆栈中弹出时，才会被删除。</p>
<p>以下代码显示了如何从容器视图控制器中删除子视图控制器。调用子视图控制器的<code>willMoveToParentViewController:</code>方法且传入<code>nil</code>值为子视图控制器提供了为更改做准备的机会。子视图控制器的<code>removeFromParentViewController</code>方法还会调用其<code>didMoveToParentViewController:</code>方法其传入<code>nil</code>值。将容器视图控制器设置为<code>nil</code>，也会从容器中删除子视图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void) hideContentController: (UIViewController*) content &#123;</div><div class="line">    [content willMoveToParentViewController:nil];</div><div class="line">    [content.view removeFromSuperview];</div><div class="line">    [content removeFromParentViewController];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="子视图控制器之间的转场动画"><a href="#子视图控制器之间的转场动画" class="headerlink" title="子视图控制器之间的转场动画"></a>子视图控制器之间的转场动画</h4><p>当需要用一个子视图控制器动画替换另一个子视图控制器时，可以将子视图控制器的添加和删除合并到转场动画过程中。在执行动画前，请确保两个子视图控制器都是容器视图控制器内容的一部分，但是让当前的子视图控制器知道它即将被移除。在动画过程中，将新子视图控制器的视图移动到位并移除旧子视图控制器的视图。动画完成后，移除旧子视图控制器。</p>
<p>以下代码显示了如何使用转场动画将一个子视图控制器替换成另一个子视图控制器的示例。在这个示例中，<code>transitionFromViewController:toViewController:duration:options:animations:completion:</code>方法会自动更新容器视图控制器的视图层次机构，不需要我们自己手动添加和删除视图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (void)cycleFromViewController:(UIViewController*)oldVC toViewController:(UIViewController*)newVC &#123;</div><div class="line">    // Prepare the two view controllers for the change.</div><div class="line">    [oldVC willMoveToParentViewController:nil];</div><div class="line">    [self addChildViewController:newVC];</div><div class="line"></div><div class="line">    // Get the start frame of the new view controller and the end frame</div><div class="line">    // for the old view controller. Both rectangles are offscreen.</div><div class="line">    newVC.view.frame = [self newViewStartFrame];</div><div class="line">    CGRect endFrame = [self oldViewEndFrame];</div><div class="line"></div><div class="line">    // Queue up the transition animation.</div><div class="line">    [self transitionFromViewController: oldVC toViewController: newVC duration: 0.25 options:0 animations:^&#123;</div><div class="line"></div><div class="line">        // Animate the views to their final positions.</div><div class="line">        newVC.view.frame = oldVC.view.frame;</div><div class="line">        oldVC.view.frame = endFrame;</div><div class="line"></div><div class="line">    &#125;completion:^(BOOL finished) &#123;</div><div class="line">        // Remove the old view controller and send the final</div><div class="line">        // notification to the new view controller.</div><div class="line">        [oldVC removeFromParentViewController];</div><div class="line">        [newVC didMoveToParentViewController:self];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="管理子视图控制器的外观更新"><a href="#管理子视图控制器的外观更新" class="headerlink" title="管理子视图控制器的外观更新"></a>管理子视图控制器的外观更新</h4><p>在将子视图控制器添加到容器视图控制器后，容器视图控制器会自动将外观相关的消息转发给子视图控制器。大多数情况下，这样能确保所有事件都正确发生。但是，有时默认行为可能会以无意义的顺序发送这些事件。例如，如果多个子视图控制器同时改变其视图状态，则可能需要合并这些更改，以使外观回调都以更合理的顺序同时发生。</p>
<p>要接管外观回调的责任，需要覆写容器视图控制器的<code>shouldAutomaticallyForwardAppearanceMethods</code>方法并返回<code>NO</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL) shouldAutomaticallyForwardAppearanceMethods &#123;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当有转场动画发生时，根据需要调用子视图控制器的<code>beginAppearanceTransition:animated:</code>或者<code>endAppearanceTransition</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-(void) viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self.child beginAppearanceTransition: YES animated: animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void) viewDidAppear:(BOOL)animated &#123;</div><div class="line">    [self.child endAppearanceTransition];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void) viewWillDisappear:(BOOL)animated &#123;</div><div class="line">    [self.child beginAppearanceTransition: NO animated: animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void) viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    [self.child endAppearanceTransition];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="自定义容器视图控制器的几点建议"><a href="#自定义容器视图控制器的几点建议" class="headerlink" title="自定义容器视图控制器的几点建议"></a>自定义容器视图控制器的几点建议</h4><p>设计、开发和测试新的容器视图控制器需要时间。虽然每个视图控制器的行为是直截了当的，但整体控制起来可能相当复杂。在自定义容器控制器时，请考虑以下提示：</p>
<ul>
<li>只访问子视图控制器的根视图。容器视图控制器只能访问每个子视图控制器的根视图，也就是子视图控制器的<code>view</code>属性，它不应该访问任何子视图控制器的其他视图。</li>
<li>子视图控制器应该对其容器视图控制器有最少的了解。子视图控制器应该关注自己的内容。如果容器视图控制器允许其行为受到子视图控制器的影响，则应该使用委托设计模式来管理这些交互。</li>
<li>首选使用常规视图来设计容器视图控制器。使用常规视图（而不是来自子视图控制器的视图）使我们有机会在简单的环境中测试布局约束和转场动画。当常规视图能按照预期工作时，再将常规视图替换成子视图控制器的视图。</li>
</ul>
<h4 id="将控制委派给子视图控制器"><a href="#将控制委派给子视图控制器" class="headerlink" title="将控制委派给子视图控制器"></a>将控制委派给子视图控制器</h4><p>容器视图控制器可以将其自身外观的某些方面委托给其一个或多个子视图控制器。可以通过以下方式委派控制权：</p>
<ul>
<li>让一个子视图控制器确定状态栏的样式。要将状态栏外观委托给子视图控制器，需要覆写容器视图控制器的<code>childViewControllerForStatusBarStyle</code>和<code>childViewControllerForStatusBarHidden</code>方法中的一个或者两个。</li>
<li>让子视图控制器指定自己的尺寸。具有灵活布局的容器视图控制器可以使用其子视图控制器的<code>preferredContentSize</code>属性来帮助确定子视图控制器的尺寸。</li>
</ul>
<h2 id="支持辅助功能"><a href="#支持辅助功能" class="headerlink" title="支持辅助功能"></a>支持辅助功能</h2><p>iOS系统为了帮助盲人进行人机交互，设计了VoiceOver读屏技术。VoiceOver能够读出屏幕上的信息，其属于辅助功能的一部分。有关让<code>UIViewController</code>支持辅助功能的详细信息，请参看<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/SupportingAccessibility.html#//apple_ref/doc/uid/TP40007457-CH12-SW1" target="_blank" rel="external">Supporting Accessibility</a>。</p>
<h2 id="保存和恢复状态"><a href="#保存和恢复状态" class="headerlink" title="保存和恢复状态"></a>保存和恢复状态</h2><p>视图控制器在应用程序状态保存和恢复过程中起着重要作用。状态保存会在应用程序被挂起之前保存其当前配置，以便后续应用程序启动时恢复之前的配置。将应用程序恢复到以前的配置为用户节省来时间，并提供来更好的用户体验。</p>
<p>保存和恢复过程大都是自动的，但是需要我们告知系统应用程序的哪些部分要保存。保存应用程序的视图控制器的步骤如下：</p>
<ul>
<li>（必需）将恢复标识符分配给要保留其配置的视图控制器。</li>
<li>（必需）告诉系统如何在启动时创建或定位新的视图控制器对象。</li>
<li>（可选）对于每个视图控制器，存储能将视图控制器返回到其之前配置所需的任何特定配置数据。</li>
</ul>
<p>有关保存和恢复过程的概述，可以参看<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_blank" rel="external">App Programming Guide for iOS</a>。</p>
<h3 id="标记需要保存的视图控制器"><a href="#标记需要保存的视图控制器" class="headerlink" title="标记需要保存的视图控制器"></a>标记需要保存的视图控制器</h3><p>UIKit只会保存被标记需要保存的视图控制器。每个视图控制器都有一个<code>restorationIdentifier</code>属性，其默认值为<code>nil</code>，为该属性设置有效的字符串值将告诉UIKit应该保存视图控制器及其视图。我们可以以编程方式或在storyboard中为视图控制器分配恢复标识符。</p>
<p><strong>分配恢复标识符时，一定要记住，当前视图控制器层次结构中的所有父视图控制器也必须具有恢复标识符。</strong>在保存过程中，UIKit从window的根视图控制器开始，遍历当前视图控制器层次结构。如果该层次结构中的视图控制器没有恢复标识符，则视图控制器及其所有子视图控制器和呈现的视图控制器都将被忽略。</p>
<h3 id="选择有效的恢复标识符"><a href="#选择有效的恢复标识符" class="headerlink" title="选择有效的恢复标识符"></a>选择有效的恢复标识符</h3><p>UIKit会使用我们分配的恢复标识符去重新创建视图控制器，所以需要选择容易被代码识别的字符串来作为恢复标识符。如果UIKit无法自动创建一个视图控制器，其会要求我们自己手动创建，并为我们提供视图控制器及其所有父视图控制器的恢复标识符。这个标识符链标表示视图控制器的恢复路径，以及如何确定正在请求哪个视图控制器。恢复路径从根视图控制器开始，直至所请求的视图控制器。</p>
<p>恢复标识符通常是视图控制器的类名。如果在许多地方使用相同的类，则可能需要分配更有意义的值。例如，可以根据视图控制器管理的数据分配一个字符串。</p>
<p>每个视图控制器的恢复路径必须是唯一的。如果容器视图控制器有两个子视图控制器，容器视图控制器必须为每个子视图控制器分配一个唯一的恢复标识符。UIKit中的一些容器视图控制器会自动消除其子视图控制器的歧义，使得我们可以为每个子视图控制器使用相同的恢复标识符。例如，<code>UINavigationController</code>类会根据其子视图控制器在导航堆栈中的位置给其子视图控制器添加信息。</p>
<h3 id="排除视图控制器组"><a href="#排除视图控制器组" class="headerlink" title="排除视图控制器组"></a>排除视图控制器组</h3><p>要在恢复过程中排除整个视图控制器组，请将父视图控制器的恢复标识符设置为<code>nil</code>。下图显示了将视图控制器层次结构中的视图控制器的恢复标识符设为<code>nil</code>的影响。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4906302-05ae784f9afe71e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8-1"></p>
<p>排除一个或者多个视图控制器并不会在随后的恢复过程中完全移除这些视图控制器。在应用程序启动时，任何视图控制器都是应用程序的默认配置的一部分，它们仍然会被创建，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4906302-5df6d24c8fc02a4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8-2"></p>
<p>在自动保存过程中排除视图控制器并不会阻止我们去手动保存它。在恢复归档中，保存对视图控制器的引用可以保留视图控制器及其状态信息。例如，如果图7-1中的应用程序委托保存了导航控制器的三个子项，则它们的状态将被保留。在还原期间，应用程序委托可以重新创建这些视图控制器并将其推送到导航控制器的堆栈中。</p>
<h3 id="保存视图控制器的视图"><a href="#保存视图控制器的视图" class="headerlink" title="保存视图控制器的视图"></a>保存视图控制器的视图</h3><p>一些视图具有与视图相关的附加状态信息，例如我们可能想保存滚动视图的滚动位置。当视图控制器负责提供滚动视图的内容时，滚动视图本身负责保持其视觉状态。</p>
<p>要保存视图的状态，需要执行以下操作：</p>
<ul>
<li>为视图的<code>restorationIdentifier</code>属性分配一个有效的字符串。</li>
<li>使用也具有有效的恢复标识符的视图控制器中的视图。</li>
<li>对于表视图和集合视图，分配一个遵循<code>UIDataSourceModelAssociation</code>协议的数据源对象。</li>
</ul>
<p>为视图分配一个恢复标识符将告知UIKit应该将视图的状态写入恢复归档，当视图控制器稍后被恢复时，UIKit还恢复具有恢复标识符的任何视图的状态。</p>
<h3 id="在应用程序启动时恢复视图控制器"><a href="#在应用程序启动时恢复视图控制器" class="headerlink" title="在应用程序启动时恢复视图控制器"></a>在应用程序启动时恢复视图控制器</h3><p>在应用程序启动时，UIKit会尝试将应用程序恢复到之前的状态。此时，UIKit会要求应用程序创建（或定位）包含之前保存的用户界面的视图控制器。UIKit在尝试定位视图控制器时，会按照以下顺序去搜索：</p>
<ol>
<li>如果视图控制器有恢复类，UIkit会要求该类提供视图控制器。UIKit会调用关联的恢复类的<code>viewControllerWithRestorationIdentifierPath:coder:</code>方法来检索视图控制器。如果该方法返回<code>nil</code>，UIkit会假定应用程序不用重新创建视图控制器并且会停止查找。</li>
<li>如果视图控制器没有关联恢复类，UIKit会要求应用程序委托提供视图控制器。UIKit调用应用程序委托的<code>application:viewControllerWithRestorationIdentifierPath:coder:</code>方法来查找没有恢复类的视图控制器。如果该方法返回<code>nil</code>，UIKit将尝试隐式查找视图控制器。</li>
<li>如果具有正确恢复路径的视图控制器已经存在，UIKit就会使用该视图控制器对象。如果应用程序在启动时创建视图控制器（以编程方式或者从storyboard中加载），且视图控制器具有恢复标识符，则UIKit会根据其恢复路径隐式查找它们。</li>
<li>如果视图控制器最初是从storyboarrd中加载的，则UIKit使用保存的storyboard信息来定位和创建它。UIKit将有关视图控制器的storyboard信息保存在恢复归档中，在恢复时，UIKit使用该信息来定位相同的storyboard文件，并且会在使用任何其他方式都没有查找到视图控制器的情况下实例化相应的视图控制器。</li>
</ol>
<p>为视图控制器分配一个恢复类可以避免UIKit隐式地检索该视图控制器。使用恢复类可以更好地控制是否真的要创建视图控制器。例如，如果恢复类确定不应该重新创建视图控制器，则<code>viewControllerWithRestorationIdentifierPath:coder:</code>方法可以返回<code>nil</code>。当没有恢复类时，UIKit会尽其所能找到或者创建视图控制器，并将其恢复。</p>
<p>当使用恢复类时，<code>viewControllerWithRestorationIdentifierPath:coder:</code>方法应该创建一个类的新实例对象，执行最低限度的初始化，并返回结果对象。以下代码展示了一个如何使用此方法从storyboard中加载视图控制器的例子。由于视图控制器最初是从storyboard加载的，因此此方法使用<code>UIStateRestorationViewControllerStoryboardKey</code>键值从存档中获取storyboard。<strong>注意，此方法不会尝试配置视图控制器的数据内容。当视图控制器的状态被解码后，才会去配置视图控制器的数据内容。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (UIViewController*)viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents coder:(NSCoder *)coder &#123;</div><div class="line">    MyViewController* vc;</div><div class="line">    </div><div class="line">    UIStoryboard* sb = [coder decodeObjectForKey:UIStateRestorationViewControllerStoryboardKey];</div><div class="line">    if (sb) &#123;</div><div class="line">        vc = (PushViewController*)[sb instantiateViewControllerWithIdentifier:@&quot;MyViewController&quot;];</div><div class="line">        vc.restorationIdentifier = [identifierComponents lastObject];</div><div class="line">        vc.restorationClass = [MyViewController class];</div><div class="line">    &#125;</div><div class="line">    return vc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在手动重新创建视图控制器时，重新分配恢复标识符和恢复类是一个好习惯。恢复恢复标识符的最简单方法是获取<code>identifierComponents</code>数组中的最后一项，并将其分配给视图控制器。</p>
<p>对于在应用程序启动时从<strong>main storyboard</strong>文件中创建的对象，请勿为每个对象创建新的实例。请让UIKit隐式查找这些对象，或者使用应用程序委托对象的<code>application:viewControllerWithRestorationIdentifierPath:coder:</code>方法来查找现有对象。</p>
<h3 id="编码和解码视图控制器的状态"><a href="#编码和解码视图控制器的状态" class="headerlink" title="编码和解码视图控制器的状态"></a>编码和解码视图控制器的状态</h3><p>对于每个要保存的对象，UIKit都会调用对象的<code>encodeRestorableStateWithCoder:</code>方法，使其有机会保存其状态。在恢复过程中，UIKit会调用对应的<code>decodeRestorableStateWithCoder:</code>方法来解码该状态并将其用于对象。对于视图控制器，这些方法的实现是可选的，但建议实现。可以使用它们来保存和恢复以下类型的信息：</p>
<ul>
<li>关联引用所显示的任何数据（不是数据本身）。</li>
<li>对于容器视图控制器，关联引用其子视图控制器。</li>
<li>与当前选择有关的信息。</li>
<li>对于具有用户可配置视图的视图控制器，提供关于该视图当前配置的信息。</li>
</ul>
<p>在编码和解码方法中，可以对编码器支持的对象和任何数据类型进行编码。对于除视图和视图控制器以外的所有对象，对象必须遵循<code>NSCoding</code>协议，并使用该协议的方法来写入其状态。对于视图和视图控制器，编码器并不使用<code>NSCoding</code>协议来保存对象的状态。取而代之的是，编码器保存对象的恢复标识符并将其添加到可保存对象的列表中，这会导致对象的<code>encodeRestorableStateWithCoder:</code>方法被调用。</p>
<p>在实现视图控制器的<code>encodeRestorableStateWithCoder:</code>和<code>decodeRestorableStateWithCoder:</code>方法时，必须调用<code>super</code>的该方法。调用<code>super</code>的该方法让父类有机会保存和恢复任何附加信息。以下代码展示来这些方法的一个示例实现，它们保存用于标识指定视图控制器的数字值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)encodeRestorableStateWithCoder:(NSCoder *)coder &#123;</div><div class="line">    [super encodeRestorableStateWithCoder:coder];</div><div class="line"></div><div class="line">    [coder encodeInt:self.number forKey:MyViewControllerNumber];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)decodeRestorableStateWithCoder:(NSCoder *)coder &#123;</div><div class="line">    [super decodeRestorableStateWithCoder:coder];</div><div class="line"></div><div class="line">    self.number = [coder decodeIntForKey:MyViewControllerNumber];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编码器对象在编码和解码过程并不共享。每个具有可保存状态的对象都会接收到自己的编码器对象。使用各自的编码器意味着我们不用担心密钥之间的命名空间冲突。但是，请不要使用<code>UIApplicationStateRestorationBundleVersionKey</code>、<code>UIApplicationStateRestorationUserInterfaceIdiomKey</code>和<code>UIStateRestorationViewControllerStoryboardKey</code>键名称。UIKit使用这些键来存储关于视图控制器状态的附加信息。</p>
<p>有关实现视图控制器的编码和解码的更多信息，请参看<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller" target="_blank" rel="external">UIViewController Class Reference</a>。</p>
<h3 id="保存和恢复视图控制器的几点建议"><a href="#保存和恢复视图控制器的几点建议" class="headerlink" title="保存和恢复视图控制器的几点建议"></a>保存和恢复视图控制器的几点建议</h3><p>在视图控制器中添加对状态保存和恢复的支持时，请考虑以下准则：</p>
<ul>
<li>请记住，我们可能不想保留所有视图控制器。在某些情况下，保留视图控制器可能没有意义。例如，如果应用程序正在显示更改，则可能需要取消操作并将应用程序还原到上一个屏幕。在这种情况下，我们不需要保留要求输入新密码信息的视图控制器。</li>
<li>避免在恢复过程中换掉视图控制器对象所属的类。状态保存系统对它保存的视图控制器的类进行进行编码。在恢复过程中，如果应用程序返回的对象的类不匹配（或者不是原始对象的子类），则系统不会要求视图控制器解码任何状态信息。</li>
<li>状态保存系统希望我们按照预期使用视图控制器。恢复过程依赖于视图控制器的包含关系来重建界面。如果我们没有正确使用容器视图控制器，保存系统将找不到视图控制器。例如，除非在相应的视图控制器之间存在包含关系，否则不要将视图控制器的视图嵌入到不同的视图中。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/27/UIViewController详解-概述/" rel="next" title="UIViewController详解 -- 概述">
                <i class="fa fa-chevron-left"></i> UIViewController详解 -- 概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/04/UIViewController详解-呈现和转场动画/" rel="prev" title="UIViewController详解 -- 呈现和转场动画">
                UIViewController详解 -- 呈现和转场动画 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="ShiJian" />
          <p class="site-author-name" itemprop="name">ShiJian</p>
           
              <p class="site-description motion-element" itemprop="description">光阴给我们经验,读书给我们知识.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhangshijian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/shijianzzzz" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#子类化视图控制器"><span class="nav-number">1.</span> <span class="nav-text">子类化视图控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计UI"><span class="nav-number">1.1.</span> <span class="nav-text">设计UI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理用户交互"><span class="nav-number">1.2.</span> <span class="nav-text">处理用户交互</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在运行时显示视图"><span class="nav-number">1.3.</span> <span class="nav-text">在运行时显示视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理视图布局"><span class="nav-number">1.4.</span> <span class="nav-text">管理视图布局</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个容器视图控制器"><span class="nav-number">2.</span> <span class="nav-text">实现一个容器视图控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计自定义容器视图控制器"><span class="nav-number">2.1.</span> <span class="nav-text">设计自定义容器视图控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例：导航控制器"><span class="nav-number">2.2.</span> <span class="nav-text">示例：导航控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例：分割控制器"><span class="nav-number">2.3.</span> <span class="nav-text">示例：分割控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在Interface-Builder中配置容器"><span class="nav-number">2.4.</span> <span class="nav-text">在Interface Builder中配置容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现自定义容器视图控制器"><span class="nav-number">2.5.</span> <span class="nav-text">实现自定义容器视图控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将子视图控制器添加到内容"><span class="nav-number">2.5.1.</span> <span class="nav-text">将子视图控制器添加到内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移除子视图控制器"><span class="nav-number">2.5.2.</span> <span class="nav-text">移除子视图控制器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子视图控制器之间的转场动画"><span class="nav-number">2.5.3.</span> <span class="nav-text">子视图控制器之间的转场动画</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管理子视图控制器的外观更新"><span class="nav-number">2.5.4.</span> <span class="nav-text">管理子视图控制器的外观更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义容器视图控制器的几点建议"><span class="nav-number">2.5.5.</span> <span class="nav-text">自定义容器视图控制器的几点建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将控制委派给子视图控制器"><span class="nav-number">2.5.6.</span> <span class="nav-text">将控制委派给子视图控制器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#支持辅助功能"><span class="nav-number">3.</span> <span class="nav-text">支持辅助功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保存和恢复状态"><span class="nav-number">4.</span> <span class="nav-text">保存和恢复状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记需要保存的视图控制器"><span class="nav-number">4.1.</span> <span class="nav-text">标记需要保存的视图控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择有效的恢复标识符"><span class="nav-number">4.2.</span> <span class="nav-text">选择有效的恢复标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排除视图控制器组"><span class="nav-number">4.3.</span> <span class="nav-text">排除视图控制器组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保存视图控制器的视图"><span class="nav-number">4.4.</span> <span class="nav-text">保存视图控制器的视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在应用程序启动时恢复视图控制器"><span class="nav-number">4.5.</span> <span class="nav-text">在应用程序启动时恢复视图控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码和解码视图控制器的状态"><span class="nav-number">4.6.</span> <span class="nav-text">编码和解码视图控制器的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保存和恢复视图控制器的几点建议"><span class="nav-number">4.7.</span> <span class="nav-text">保存和恢复视图控制器的几点建议</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShiJian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://ShiJian.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/04/15/UIViewController详解-视图控制器定义/';
          this.page.identifier = '2017/04/15/UIViewController详解-视图控制器定义/';
          this.page.title = 'UIViewController详解 -- 视图控制器定义';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://ShiJian.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
